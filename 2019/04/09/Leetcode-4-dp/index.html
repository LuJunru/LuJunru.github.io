<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Leetcode,Algorithm,">










<meta name="description" content="这篇文章不仅是总结Leetcode上关于DP的题，也恰好是总结一下算法课中关于DP的内容。 Longest Common Subsequence Problem: 最长公共子序列。给定两个字符串，判定公共子序列的最大长度，这里的子序列可以是不连续的。Leetcode上有一道近似题：Given two words word1 and word2, find the minimum number of">
<meta name="keywords" content="Leetcode,Algorithm">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode 4: dp">
<meta property="og:url" content="http://yoursite.com/2019/04/09/Leetcode-4-dp/index.html">
<meta property="og:site_name" content="Junru">
<meta property="og:description" content="这篇文章不仅是总结Leetcode上关于DP的题，也恰好是总结一下算法课中关于DP的内容。 Longest Common Subsequence Problem: 最长公共子序列。给定两个字符串，判定公共子序列的最大长度，这里的子序列可以是不连续的。Leetcode上有一道近似题：Given two words word1 and word2, find the minimum number of">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-06-14T21:07:07.884Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode 4: dp">
<meta name="twitter:description" content="这篇文章不仅是总结Leetcode上关于DP的题，也恰好是总结一下算法课中关于DP的内容。 Longest Common Subsequence Problem: 最长公共子序列。给定两个字符串，判定公共子序列的最大长度，这里的子序列可以是不连续的。Leetcode上有一道近似题：Given two words word1 and word2, find the minimum number of">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/04/09/Leetcode-4-dp/">





  <title>Leetcode 4: dp | Junru</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Junru</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-resume">
          <a href="/resume/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-file"></i> <br>
            
            Resume
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            Commonweal 404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/09/Leetcode-4-dp/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Junru Lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/29519546.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Junru">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode 4: dp</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-09T15:53:36-04:00">
                2019-04-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/04/09/Leetcode-4-dp/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/04/09/Leetcode-4-dp/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/04/09/Leetcode-4-dp/" class="leancloud_visitors" data-flag-title="Leetcode 4: dp">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>views
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>这篇文章不仅是总结Leetcode上关于DP的题，也恰好是总结一下算法课中关于DP的内容。</p>
<h1 id="Longest-Common-Subsequence"><a href="#Longest-Common-Subsequence" class="headerlink" title="Longest Common Subsequence"></a>Longest Common Subsequence</h1><ul>
<li>Problem: 最长公共子序列。给定两个字符串，判定公共子序列的最大长度，这里的子序列可以是不连续的。Leetcode上有一道近似题：Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string.</li>
<li>Example: Input: “sea”, “eat”, output: 2. Explanation: You need one step to make “sea” to “ea” and another step to make “eat” to “ea”. 其实就是找出LCS的长度，然后减一下。</li>
<li>Link: <a href="https://leetcode.com/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener">https://leetcode.com/problems/delete-operation-for-two-strings/</a></li>
<li>Answer:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"># 1: 递归，O(2^m)，超时</span><br><span class="line">class Solution:</span><br><span class="line">    def minDistance(self, word1: str, word2: str) -&gt; int:</span><br><span class="line">        def LCS(X, Y, i, j):</span><br><span class="line">            if i == -1 or j == -1:</span><br><span class="line">                return 0</span><br><span class="line">            if X[i] == Y[j]:</span><br><span class="line">                return LCS(X, Y, i - 1, j - 1) + 1</span><br><span class="line">            else:</span><br><span class="line">                return max(LCS(X, Y, i - 1, j), LCS(X, Y, i, j - 1))</span><br><span class="line">            </span><br><span class="line">        word1 = list(word1)</span><br><span class="line">        word2 = list(word2)</span><br><span class="line">        return len(word1) + len(word2) - 2 * LCS(word1, word2, len(word1) - 1, len(word2) - 1)</span><br><span class="line"></span><br><span class="line"># 2: 带有memo的递归，DP，AC</span><br><span class="line">class Solution:</span><br><span class="line">    def minDistance(self, word1: str, word2: str) -&gt; int:</span><br><span class="line">        seen = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        def LCS(X, Y, i, j):</span><br><span class="line">            if (i, j) in seen:</span><br><span class="line">                return seen[(i, j)]</span><br><span class="line">            else:</span><br><span class="line">                if i == -1 or j == -1:</span><br><span class="line">                    seen[(i, j)] = 0</span><br><span class="line">                    return seen[(i, j)]</span><br><span class="line">                if X[i] == Y[j]:</span><br><span class="line">                    seen[(i, j)] = LCS(X, Y, i - 1, j - 1) + 1</span><br><span class="line">                    return seen[(i, j)]</span><br><span class="line">                else:</span><br><span class="line">                    seen[(i, j)] = max(LCS(X, Y, i - 1, j), LCS(X, Y, i, j - 1))</span><br><span class="line">                    return seen[(i, j)]</span><br><span class="line">            </span><br><span class="line">        word1 = list(word1)</span><br><span class="line">        word2 = list(word2)</span><br><span class="line">        return len(word1) + len(word2) - 2 * LCS(word1, word2, len(word1) - 1, len(word2) - 1)</span><br><span class="line"></span><br><span class="line"># 3: 优化memo的DP，二维表</span><br><span class="line">class Solution:</span><br><span class="line">    def minDistance(self, word1: str, word2: str) -&gt; int:</span><br><span class="line">        m = len(word1)</span><br><span class="line">        n = len(word2)</span><br><span class="line">        memo = [[0] * (n + 1) for i in range(m + 1)]</span><br><span class="line">        </span><br><span class="line">        for i in range(1, m + 1):</span><br><span class="line">            for j in range(1, n + 1):</span><br><span class="line">                if word1[i - 1] == word2[j - 1]:</span><br><span class="line">                    memo[i][j] = memo[i - 1][j - 1] + 1</span><br><span class="line">                else:</span><br><span class="line">                    memo[i][j] = max(memo[i - 1][j], memo[i][j - 1])</span><br><span class="line">        </span><br><span class="line">        return m + n - 2 * memo[-1][-1]</span><br><span class="line"></span><br><span class="line"># 4: 进一步优化DP，两个数组，best</span><br><span class="line">class Solution:</span><br><span class="line">    def minDistance(self, word1: str, word2: str) -&gt; int:</span><br><span class="line">        if len(word1) &lt; len(word2):</span><br><span class="line">            pass</span><br><span class="line">        else:</span><br><span class="line">            word1, word2 = word2, word1</span><br><span class="line">        s, l = len(word1), len(word2)</span><br><span class="line">        memo = [[0] * (l + 1), [0] * (l + 1)]</span><br><span class="line"></span><br><span class="line">        for i in range(s):</span><br><span class="line">            for j in range(1, l + 1):</span><br><span class="line">                if word1[i] == word2[j - 1]:</span><br><span class="line">                    memo[1][j] = memo[0][j - 1] + 1</span><br><span class="line">                else:</span><br><span class="line">                    memo[1][j] = max(memo[0][j], memo[1][j - 1])</span><br><span class="line">            memo[0], memo[1] = memo[1], memo[0]</span><br><span class="line"></span><br><span class="line">        return s + l - 2 * memo[0][-1]</span><br><span class="line"></span><br><span class="line"># 5: 若要追溯子序列，在3的基础上增加一个标记memo. 本代码来自网上</span><br><span class="line">def find_lcseque(X, Y):</span><br><span class="line">    m = len(X)</span><br><span class="line">    n = len(Y)</span><br><span class="line">    L = [[0] * (n + 1) for i in range(m + 1)]</span><br><span class="line">    B = [[&quot;D&quot;] * (n + 1) for i in range(m + 1)]</span><br><span class="line"></span><br><span class="line">    for i in range(m + 1):</span><br><span class="line">        for j in range(n + 1):</span><br><span class="line">            if i == 0 or j == 0:</span><br><span class="line">                L[i][j] = 0</span><br><span class="line">                if i == 0:</span><br><span class="line">                    B[i][j] = &quot;L&quot;</span><br><span class="line">                else:</span><br><span class="line">                    B[i][j] = &quot;U&quot;</span><br><span class="line">            elif X[i - 1] == Y[j - 1]:</span><br><span class="line">                L[i][j] = L[i - 1][j - 1] + 1</span><br><span class="line">            else:</span><br><span class="line">                if L[i - 1][j] &lt; L[i][j - 1]:</span><br><span class="line">                    L[i][j] = L[i][j - 1]</span><br><span class="line">                    B[i][j] = &quot;L&quot;</span><br><span class="line">                else:</span><br><span class="line">                    L[i][j] = L[i - 1][j]</span><br><span class="line">                    B[i][j] = &quot;U&quot;</span><br><span class="line"></span><br><span class="line">    return L, B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def track_lcseque(X, Y, Track):</span><br><span class="line">    result = []</span><br><span class="line">    start = (len(X) - 1, len(Y) - 1)</span><br><span class="line">    if Track[-1][-1] == &quot;D&quot;:</span><br><span class="line">        result.append(X[-1])</span><br><span class="line">    while start[0] or start[1]:</span><br><span class="line">        next = Track[start[0]][start[1]]</span><br><span class="line">        if next == &quot;D&quot;:</span><br><span class="line">            start = (start[0] - 1, start[1] - 1)</span><br><span class="line">            result.append(X[start[0]])</span><br><span class="line">        elif next == &quot;L&quot;:</span><br><span class="line">            start = (start[0], start[1] - 1)</span><br><span class="line">        else:</span><br><span class="line">            start = (start[0] - 1, start[1])</span><br><span class="line">    return result[::-1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = &apos;abdfg&apos;</span><br><span class="line">y = &apos;abcdfg&apos;</span><br><span class="line">l, b = find_lcseque(x, y)</span><br><span class="line">print(&quot;LCS：&quot;, end=&quot;&quot;)</span><br><span class="line">print(track_lcseque(x, y, b))</span><br><span class="line">print(&quot;LCS Len：&quot; + str(l[-1][-1]))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Longest-Common-Subarray"><a href="#Longest-Common-Subarray" class="headerlink" title="Longest Common Subarray"></a>Longest Common Subarray</h1><ul>
<li>Problem: 最长公共子串，要求连续。Leetcode上原题：Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.</li>
<li>Example: Input: A: [1,2,3,2,1], B: [3,2,1,4,7], output: 3.</li>
<li>Link: <a href="https://leetcode.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-length-of-repeated-subarray/</a></li>
<li>Answer:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># Comment: 这一题和上一题最大的区别就是找出的序列要求连续。因此两者的区别也就集中在递归方程的变化上：本题仅仅要求继承对角线上的累积和即可</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def findLength(self, word1, word2):</span><br><span class="line">        if len(word1) &lt; len(word2):</span><br><span class="line">            pass</span><br><span class="line">        else:</span><br><span class="line">            word1, word2 = word2, word1</span><br><span class="line">        s, l = len(word1), len(word2)</span><br><span class="line">        memo = [[0] * (l + 1), [0] * (l + 1)]</span><br><span class="line"></span><br><span class="line">        max_len = 0</span><br><span class="line">        for i in range(s):</span><br><span class="line">            for j in range(1, l + 1):</span><br><span class="line">                if word1[i] == word2[j - 1]:</span><br><span class="line">                    memo[1][j] = memo[0][j - 1] + 1</span><br><span class="line">                    max_len = max(max_len, memo[1][j])</span><br><span class="line">                else:</span><br><span class="line">                    memo[1][j] = 0</span><br><span class="line">            memo[0], memo[1] = memo[1], memo[0]</span><br><span class="line"></span><br><span class="line">        return max_len</span><br><span class="line"></span><br><span class="line"># 若要定位出位置，则需要加一个track变量。下面代码来自网上，不过区别不大</span><br><span class="line">def find_lcsubstr(X, Y):</span><br><span class="line">    m = len(X)</span><br><span class="line">    n = len(Y)</span><br><span class="line">    L = [[0] * (n + 1) for i in range(m + 1)]</span><br><span class="line">    max_length = 0  # 最长匹配的长度</span><br><span class="line">    p = 0  # 最长匹配对应在s1中的最后一位</span><br><span class="line">    for i in range(m):</span><br><span class="line">        for j in range(n):</span><br><span class="line">            if X[i] == Y[j]:</span><br><span class="line">                L[i + 1][j + 1] = L[i][j] + 1</span><br><span class="line">                if L[i + 1][j + 1] &gt; max_length:</span><br><span class="line">                    max_length = L[i + 1][j + 1]</span><br><span class="line">                    p = i + 1</span><br><span class="line">    return X[p - max_length:p], max_length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(find_lcsubstr(&apos;abcdfg&apos;, &apos;abdfg&apos;))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Longest-Palindromic-Subsequence"><a href="#Longest-Palindromic-Subsequence" class="headerlink" title="Longest Palindromic Subsequence"></a>Longest Palindromic Subsequence</h1><ul>
<li>Problem: 最长回文子序列。Leetcode原题：Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000.</li>
<li>Example: Input “XABCBBACXA”, output 7 (“XABCBAX”)</li>
<li>Link: <a href="https://leetcode.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-palindromic-subsequence/</a></li>
<li>Answer:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Comment: 不能用LCSeq来解决，因为虽然可以返回最大回文子序列的值，但是不一定找对序列。比如“ABCAB”，最大回文子序列是ABA，但是它和它的reverse“BACBA”的最大公共子序列可以是“ACB”，这就不是一个回文子序列</span><br><span class="line"># 用区间型动态规划来进行查找</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def longestPalindromeSubseq(self, s):</span><br><span class="line">        l = len(s)</span><br><span class="line">        memo = [[0] * l for i in range(l)]</span><br><span class="line"></span><br><span class="line">        for ll in range(l):</span><br><span class="line">            for i in range(l - ll - 1, -1, -1):  # Bottom-up</span><br><span class="line">                j = i + ll</span><br><span class="line">                if j == i:</span><br><span class="line">                    memo[i][j] = 1</span><br><span class="line">                else:</span><br><span class="line">                    if s[i] == s[j]:</span><br><span class="line">                        memo[i][j] = memo[i + 1][j - 1] + 2</span><br><span class="line">                    else:</span><br><span class="line">                        memo[i][j] = max(memo[i + 1][j], memo[i][j - 1])</span><br><span class="line"></span><br><span class="line">        return memo[0][-1]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Longest-Palindromic-Subarray"><a href="#Longest-Palindromic-Subarray" class="headerlink" title="Longest Palindromic Subarray"></a>Longest Palindromic Subarray</h1><ul>
<li>Problem: 最长回文子串。Leetcode原题：Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</li>
<li>Example: Input: “cbbd”, output: “bb”. </li>
<li>Link: <a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-palindromic-substring/</a></li>
<li>Answers:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># Comemnt: 不能用LCSub来解决，因为回文串不一定是最大子串。比如说“aacbdcaa”，镜像的最大子串是“aac”，但是回文只有“aa”</span><br><span class="line"># 用区间型动态规划来修改最大子串的查找方法</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def longestPalindrome(self, s):</span><br><span class="line">        l = len(s)</span><br><span class="line">        memo = [[0] * l for i in range(l)]</span><br><span class="line"></span><br><span class="line">        max_len = 0</span><br><span class="line">        start = end = 0</span><br><span class="line">        for ll in range(l):  # 长度从0到l</span><br><span class="line">            for i in range(l - ll - 1, -1, -1):  # Bottom-up</span><br><span class="line">                j = i + ll</span><br><span class="line">                if j == i:</span><br><span class="line">                    memo[i][j] = True</span><br><span class="line">                elif j == i + 1:</span><br><span class="line">                    memo[i][j] = (s[i] == s[j])</span><br><span class="line">                else:</span><br><span class="line">                    memo[i][j] = (memo[i + 1][j - 1] and (s[i] == s[j]))</span><br><span class="line">                if memo[i][j] and j - i + 1 &gt; max_len:</span><br><span class="line">                    max_len = j - i + 1</span><br><span class="line">                    start, end = i, j</span><br><span class="line"></span><br><span class="line">        return s[start:end + 1]</span><br><span class="line"></span><br><span class="line"># 另有一种Manacher算法，只需要O(n)：https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2</span><br><span class="line"></span><br><span class="line">def manacher(s0 : str) -&gt; list:</span><br><span class="line">    T = &apos;$#&apos; + &apos;#&apos;.join(s0) + &apos;#@&apos;</span><br><span class="line">    l = len(T)</span><br><span class="line">    P = [0] * l</span><br><span class="line">    R, C = 0, 0</span><br><span class="line">    for i in range(1,l-1):</span><br><span class="line">        if i &lt; R:</span><br><span class="line">            P[i] = min(P[2 * C - i], R - i)</span><br><span class="line">        </span><br><span class="line">        while T[i+(P[i]+1)] == T[i-(P[i]+1)]:</span><br><span class="line">            P[i] += 1</span><br><span class="line">        </span><br><span class="line">        if P[i] + i &gt; R:</span><br><span class="line">            R = P[i] + i</span><br><span class="line">            C = i</span><br><span class="line">    return P</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Longest-Increasing-Subsequence"><a href="#Longest-Increasing-Subsequence" class="headerlink" title="Longest Increasing Subsequence"></a>Longest Increasing Subsequence</h1><ul>
<li>Problem: 最长递增子序列。Leetcode: Given an unsorted array of integers, find the length of longest increasing subsequence.</li>
<li>Example: Input: [10,9,2,5,3,7,101,18], output: 4. Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.</li>
<li>Link: <a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-increasing-subsequence/</a></li>
<li>Answer:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># Comment: 最自然想到的是定义DP标记函数为L(n)，表示从1到n区间内的最长递增子序列长度。但是这样带来的问题是，当新的子序列不延续前面的子序列，而是从n+1处重新开始时，无法完成递归调用。所以需要把标记函数定义改为：从1到n区间内，使用了nums[n]的，最长递增子序列长度。因此，L(n) = 1 + max&#123;L(j), j from 1 to n - 1 &amp; nums[j] &lt; nums[n]&#125;.</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def lengthOfLIS(self, nums):</span><br><span class="line">        l = len(nums)</span><br><span class="line">        memo = [0] * l</span><br><span class="line"></span><br><span class="line">        max_len = 0</span><br><span class="line">        for i in range(l):</span><br><span class="line">            for j in range(i):</span><br><span class="line">                if nums[j] &lt; nums[i]:</span><br><span class="line">                    memo[i] = max(memo[i], memo[j])</span><br><span class="line">            memo[i] += 1</span><br><span class="line">            max_len = max(max_len, memo[i])</span><br><span class="line"></span><br><span class="line">        return max_len</span><br><span class="line"></span><br><span class="line"># 如果需要记录LIS具体是什么，加pointers回溯</span><br><span class="line"># 更好的方法：上面的方法时间复杂度是O(n^2)，我们可以在第二重循环上用Binary Search来改进查找效率，整体复杂度就会从n^2降到nlogn</span><br><span class="line">class Solution:</span><br><span class="line">    def lengthOfLIS(self, nums):</span><br><span class="line">        tails = [0] * len(nums)</span><br><span class="line">        size = 0</span><br><span class="line">        for x in nums:</span><br><span class="line">            i, j = 0, size</span><br><span class="line">            while i != j:</span><br><span class="line">                m = (i + j) // 2</span><br><span class="line">                if tails[m] &lt; x:</span><br><span class="line">                    i = m + 1</span><br><span class="line">                else:</span><br><span class="line">                    j = m</span><br><span class="line">            tails[i] = x</span><br><span class="line">            size = max(i + 1, size)</span><br><span class="line">        return size</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Longest-Increasing-Subarray"><a href="#Longest-Increasing-Subarray" class="headerlink" title="Longest Increasing Subarray"></a>Longest Increasing Subarray</h1><ul>
<li>Problem: 最长递增子串。Leetcode: Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray). </li>
<li>Example: Input: [1,3,5,4,7], output: 3</li>
<li>Link: <a href="https://leetcode.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-continuous-increasing-subsequence/</a></li>
<li>Answer:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findLengthOfLCIS(self, nums):</span><br><span class="line">        l = len(nums)</span><br><span class="line">        </span><br><span class="line">        if l &lt;= 1:</span><br><span class="line">            return l</span><br><span class="line">        </span><br><span class="line">        memo = [1] * l</span><br><span class="line"></span><br><span class="line">        max_len = 0</span><br><span class="line">        for i in range(1, l):</span><br><span class="line">            if nums[i - 1] &lt; nums[i]:</span><br><span class="line">                memo[i] = memo[i - 1] + 1</span><br><span class="line">            max_len = max(max_len, memo[i])</span><br><span class="line"></span><br><span class="line">        return max_len</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="矩阵链问题"><a href="#矩阵链问题" class="headerlink" title="矩阵链问题"></a>矩阵链问题</h1><ul>
<li>Problem: 给定一串数[a, b, c, d]，表示矩阵a<em>b、矩阵b</em>c、矩阵c<em>d相乘，判断如何控制计算顺序以达到最小计算量。矩阵a</em>b 乘 矩阵b<em>c 的计算量为a</em>b*c。</li>
<li>Example: Input [3, 1, 5, 8], output: (A1(A2A3))</li>
<li>Link: 不确定Leetcode上有没有</li>
<li>Answer:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 区间型动态规划</span><br><span class="line"></span><br><span class="line">def MATRIX_CHAIN_ORDER(p):</span><br><span class="line">    n = len(p) - 1  # n is 矩阵个数</span><br><span class="line">    m = [[0 for col in range(n + 1)] for row in range(n + 1)]  # m[i][j] is 对应矩阵计算 最优值</span><br><span class="line">    s = [[0 for col in range(n + 1)] for row in range(n + 1)]  # 分割点记录</span><br><span class="line">    for L in range(2, n + 1):  # L为矩阵链长度,依次枚举</span><br><span class="line">        for i in range(1, n - L + 2):  # n-L+1为最后一次枚举的矩阵链的起点</span><br><span class="line">            j = i + L - 1  # j为枚举的矩阵链的终点</span><br><span class="line">            m[i][j] = float(&apos;inf&apos;)  # 超出枚举的矩阵链计算量设为无穷大</span><br><span class="line">            for k in range(i, j):  # k is 分割点，枚举</span><br><span class="line">                q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]</span><br><span class="line">                if q &lt; m[i][j]:</span><br><span class="line">                    m[i][j] = q  # 新的最小值</span><br><span class="line">                    s[i][j] = k  # 分割点记录</span><br><span class="line"></span><br><span class="line">    print(&quot;最优路径：&quot;, end=&quot;&quot;)</span><br><span class="line">    PRINT_OPTIMAL_PARENS(s, 1, n)</span><br><span class="line">    return m, s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def PRINT_OPTIMAL_PARENS(s, i, j):</span><br><span class="line">    if i == j:</span><br><span class="line">        print(&quot;A&quot; + str(i), end=&apos;&apos;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;(&quot;, end=&apos;&apos;)</span><br><span class="line">        PRINT_OPTIMAL_PARENS(s, i, s[i][j])</span><br><span class="line">        PRINT_OPTIMAL_PARENS(s, s[i][j] + 1, j)</span><br><span class="line">        print(&quot;)&quot;, end=&apos;&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># test</span><br><span class="line">p = [3, 1, 5, 8]</span><br><span class="line">m, s = MATRIX_CHAIN_ORDER(p)</span><br><span class="line">print(&quot;\n最小代价：&quot; + str(max(sum(m, []))))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="取数游戏：头尾取数"><a href="#取数游戏：头尾取数" class="headerlink" title="取数游戏：头尾取数"></a>取数游戏：头尾取数</h1><ul>
<li>Problem: Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins. </li>
<li>Example: Input: [1, 5, 2], output: False. Explanation: Initially, player 1 can choose between 1 and 2. If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. Hence, player 1 will never be the winner and you need to return False.</li>
<li>Link: <a href="https://leetcode.com/problems/predict-the-winner/" target="_blank" rel="noopener">https://leetcode.com/problems/predict-the-winner/</a></li>
<li>Answer:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># Comment: 与最大回文子串、矩阵链问题一样，是区间型动态规划</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def PredictTheWinner(self, nums):</span><br><span class="line">        l = len(nums)</span><br><span class="line">        </span><br><span class="line">        if l % 2 == 0:</span><br><span class="line">            return True</span><br><span class="line"></span><br><span class="line">        memo = [[0] * l for k in range(l)]</span><br><span class="line"></span><br><span class="line">        sum_nums = 0</span><br><span class="line">        for ll in range(l):  # 长度从0到l</span><br><span class="line">            sum_nums += nums[ll]</span><br><span class="line">            for i in range(l - ll):  # i从头到l - 长度</span><br><span class="line">                j = i + ll</span><br><span class="line">                if j == i:</span><br><span class="line">                    memo[i][j] = nums[i]</span><br><span class="line">                elif j == i + 1:</span><br><span class="line">                    memo[i][j] = max(nums[i], nums[j])</span><br><span class="line">                else:</span><br><span class="line">                    left = min(memo[i + 1][j - 1], memo[i + 2][j]) + nums[i]</span><br><span class="line">                    right = min(memo[i][j - 2], memo[i + 1][j - 1]) + nums[j]</span><br><span class="line">                    memo[i][j] = max(left, right)</span><br><span class="line"></span><br><span class="line">        return memo[0][-1] * 2 &gt;= sum_nums</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="rod-cutting：切钢管"><a href="#rod-cutting：切钢管" class="headerlink" title="rod cutting：切钢管"></a>rod cutting：切钢管</h1><ul>
<li>Problem: 给定一根钢管，告知其每整数段的售价，问最大售价及最佳切割办法。</li>
<li>Example: l = [1, 2, 3, 4, 5, 6, 7, 8], p = [1, 5, 8, 9, 10, 17, 17, 20], 则最佳切割是在(2, 6)或(6, 2)处，总售价为5 + 17 = 22。</li>
<li>Link: 暂未找到</li>
<li>Answer: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">l = [1, 2, 3, 4, 5, 6, 7, 8]</span><br><span class="line">p = [1, 5, 8, 9, 10, 17, 17, 20]</span><br><span class="line"></span><br><span class="line">r = l[:]</span><br><span class="line">v = [p[0]] * len(l)</span><br><span class="line">for i in range(1, len(l)):</span><br><span class="line">    for j in range(i):</span><br><span class="line">        if p[j] + v[i - j - 1] &gt; v[i]:</span><br><span class="line">            v[i] = p[j] + v[i - j - 1]</span><br><span class="line">            r[i] = i - j</span><br><span class="line">    if p[i] &gt; v[i]:</span><br><span class="line">        v[i] = p[i]</span><br><span class="line">        r[i] = i + 1</span><br><span class="line">print(&quot;最大价值：&quot; + str(v[-1]))</span><br><span class="line"></span><br><span class="line">res = []</span><br><span class="line">left = len(l)</span><br><span class="line">while left &gt; 0:</span><br><span class="line">    res.append(r[left - 1])</span><br><span class="line">    left -= r[left - 1]</span><br><span class="line">print(&quot;最佳切割：&quot; + str(res))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h1><ul>
<li>Problem: 有N种物品(每个1件)和一个容量为V的背包。第i建物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。</li>
<li>Example: Bag = 14, Weight = [3, 2, 6, 7, 2, 4, 9, 5], Value = [6, 3, 5, 8, 3, 1, 6, 9]. Solution is items in index [1, 2, 5, 8], maximum value is 21.</li>
<li>Link: 暂未找到</li>
<li>Answer:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">def OneNPPack(w, v, b):</span><br><span class="line">    w.insert(0, 0)</span><br><span class="line">    v.insert(0, 0)</span><br><span class="line">    k = len(w)</span><br><span class="line">    memo = [[0 for bb in range(b + 1)] for kk in range(k)]</span><br><span class="line">    indx = [[0 for bb in range(b + 1)] for kk in range(k)]</span><br><span class="line">    for i in range(1, k):</span><br><span class="line">        for j in range(1, b + 1):</span><br><span class="line">            if j &lt; w[i]:  # 边界情况，装不下第k个物品</span><br><span class="line">                memo[i][j] = memo[i - 1][j]</span><br><span class="line">                indx[i][j] = indx[i - 1][j]</span><br><span class="line">            else:  # 能装下第k个物品时，在两种情况中选一个</span><br><span class="line">                if memo[i - 1][j] &lt; memo[i - 1][j - w[i]] + v[i]:  # 装入第k个物品</span><br><span class="line">                    memo[i][j] = memo[i - 1][j - w[i]] + v[i]</span><br><span class="line">                    indx[i][j] = i</span><br><span class="line">                else:  # 不装第k个物品</span><br><span class="line">                    memo[i][j] = memo[i - 1][j]</span><br><span class="line">                    indx[i][j] = indx[i - 1][j]</span><br><span class="line">    return memo, indx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def OneNTrack(w, b, track):</span><br><span class="line">    start = track[-1][-1]</span><br><span class="line">    holds = []</span><br><span class="line">    length = b</span><br><span class="line">    while length &gt; 0 and start &gt; 0:</span><br><span class="line">        holds.append(start)</span><br><span class="line">        length -= w[start]</span><br><span class="line">        next = track[start - 1][length]</span><br><span class="line">        start = next</span><br><span class="line">    return holds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Bag = 14</span><br><span class="line">Weight = [3, 2, 6, 7, 2, 4, 9, 5]</span><br><span class="line">Value = [6, 3, 5, 8, 3, 1, 6, 9]</span><br><span class="line">value, track = OneNPPack(Weight, Value, Bag)</span><br><span class="line">print(&quot;最大价值：&quot; + str(value[-1][-1]))</span><br><span class="line">print(&quot;装入物品：&quot;, end=&quot;&quot;)</span><br><span class="line">print(OneNTrack(Weight, Bag, track))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><ul>
<li>Problem: 有N种物品(每个无数件)和一个容量为V的背包。第i建物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。</li>
<li>Example: Bag = 14, Weight = [3, 2, 6, 7, 2, 4, 9, 5], Value = [6, 3, 5, 8, 3, 1, 6, 9]. Solution is items in index [2, 1, 1, 1, 1], maximum value is 27.</li>
<li>Link: 暂未找到</li>
<li>Answer:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">def KNPPack(w, v, b):</span><br><span class="line">    w.insert(0, 0)</span><br><span class="line">    v.insert(0, 0)</span><br><span class="line">    k = len(w)</span><br><span class="line">    memo = [[0 for bb in range(b + 1)] for kk in range(k)]</span><br><span class="line">    indx = [[0 for bb in range(b + 1)] for kk in range(k)]</span><br><span class="line">    for i in range(1, k):</span><br><span class="line">        for j in range(1, b + 1):</span><br><span class="line">            if i == 1:</span><br><span class="line">                memo[i][j] = (j // w[i]) * v[i]</span><br><span class="line">                if j &lt; w[i]:  # 无法装入第1个物品</span><br><span class="line">                    indx[i][j] = 0</span><br><span class="line">                else:  # 可装入第一个物品</span><br><span class="line">                    indx[i][j] = i</span><br><span class="line">            else:</span><br><span class="line">                if j &lt; w[i]:</span><br><span class="line">                    memo[i][j] = memo[i - 1][j]</span><br><span class="line">                    indx[i][j] = indx[i - 1][j]</span><br><span class="line">                else:</span><br><span class="line">                    if memo[i - 1][j] &lt; memo[i][j - w[i]] + v[i]:  # 装入第k个物品</span><br><span class="line">                        memo[i][j] = memo[i][j - w[i]] + v[i]</span><br><span class="line">                        indx[i][j] = i</span><br><span class="line">                    else:  # 不装第k个物品</span><br><span class="line">                        memo[i][j] = memo[i - 1][j]</span><br><span class="line">                        indx[i][j] = indx[i - 1][j]</span><br><span class="line">    return memo, indx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def KNTrack(w, b, track):</span><br><span class="line">    start = track[-1][-1]</span><br><span class="line">    holds = []</span><br><span class="line">    length = b</span><br><span class="line">    while length &gt; 0:</span><br><span class="line">        holds.append(start)</span><br><span class="line">        length -= w[start]</span><br><span class="line">        next = track[start][length]</span><br><span class="line">        start = next</span><br><span class="line">    return holds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Bag = 14</span><br><span class="line">Weight = [3, 2, 6, 7, 2, 4, 9, 5]</span><br><span class="line">Value = [6, 3, 5, 8, 3, 1, 6, 9]</span><br><span class="line">value, track = KNPPack(Weight, Value, Bag)</span><br><span class="line">print(&quot;最大价值：&quot; + str(value[-1][-1]))</span><br><span class="line">print(&quot;装入物品：&quot;, end=&quot;&quot;)</span><br><span class="line">print(KNTrack(Weight, Bag, track))</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          
            <a href="/tags/Algorithm/" rel="tag"># Algorithm</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/02/Leetcode-3-stock/" rel="next" title="Leetcode 3: stock">
                <i class="fa fa-chevron-left"></i> Leetcode 3: stock
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/11/Interview-review-from-NuoChen/" rel="prev" title="Interview review from Nuo Chen">
                Interview review from Nuo Chen <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/29519546.png" alt="Junru Lu">
            
              <p class="site-author-name" itemprop="name">Junru Lu</p>
              <p class="site-description motion-element" itemprop="description">Keep moving</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/LuJunru" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:junru31415926@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.linkedin.com/in/junrulu/" target="_blank" title="Linkin">
                      
                        <i class="fa fa-fw fa-linkedin"></i>Linkin</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://leetcode.com/lujunru/" target="_blank" title="Leetcode">
                      
                        <i class="fa fa-fw fa-link"></i>Leetcode</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Longest-Common-Subsequence"><span class="nav-number">1.</span> <span class="nav-text">Longest Common Subsequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Longest-Common-Subarray"><span class="nav-number">2.</span> <span class="nav-text">Longest Common Subarray</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Longest-Palindromic-Subsequence"><span class="nav-number">3.</span> <span class="nav-text">Longest Palindromic Subsequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Longest-Palindromic-Subarray"><span class="nav-number">4.</span> <span class="nav-text">Longest Palindromic Subarray</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Longest-Increasing-Subsequence"><span class="nav-number">5.</span> <span class="nav-text">Longest Increasing Subsequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Longest-Increasing-Subarray"><span class="nav-number">6.</span> <span class="nav-text">Longest Increasing Subarray</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#矩阵链问题"><span class="nav-number">7.</span> <span class="nav-text">矩阵链问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#取数游戏：头尾取数"><span class="nav-number">8.</span> <span class="nav-text">取数游戏：头尾取数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#rod-cutting：切钢管"><span class="nav-number">9.</span> <span class="nav-text">rod cutting：切钢管</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0-1背包问题"><span class="nav-number">10.</span> <span class="nav-text">0-1背包问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#完全背包问题"><span class="nav-number">11.</span> <span class="nav-text">完全背包问题</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Junru Lu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      views
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      views
    </span>
  
</div>








        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'TESN0aruYWfEKaMV36cdA8qo-gzGzoHsz',
        appKey: '73zKQnJQHrfIPjWV2puu1YS3',
        placeholder: '(￣∇￣)来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("TESN0aruYWfEKaMV36cdA8qo-gzGzoHsz", "73zKQnJQHrfIPjWV2puu1YS3");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
