<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Interview review from Nuo Chen]]></title>
    <url>%2F2019%2F04%2F11%2FInterview-review-from-NuoChen%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>Internship</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-4-dp]]></title>
    <url>%2F2019%2F04%2F09%2FLeetcode-4-dp%2F</url>
    <content type="text"><![CDATA[这篇文章不仅是总结Leetcode上关于DP的题，也恰好是总结一下算法课中关于DP的内容。 Longest Common Subsequence Problem: 最长公共子序列。给定两个字符串，判定公共子序列的最大长度，这里的子序列可以是不连续的。Leetcode上有一道近似题：Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string. Example: Input: “sea”, “eat”, output: 2. Explanation: You need one step to make “sea” to “ea” and another step to make “eat” to “ea”. 其实就是找出LCS的长度，然后减一下。 Link: https://leetcode.com/problems/delete-operation-for-two-strings/ Answer:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125# 1: 递归，O(2^m)，超时class Solution: def minDistance(self, word1: str, word2: str) -&gt; int: def LCS(X, Y, i, j): if i == -1 or j == -1: return 0 if X[i] == Y[j]: return LCS(X, Y, i - 1, j - 1) + 1 else: return max(LCS(X, Y, i - 1, j), LCS(X, Y, i, j - 1)) word1 = list(word1) word2 = list(word2) return len(word1) + len(word2) - 2 * LCS(word1, word2, len(word1) - 1, len(word2) - 1)# 2: 带有memo的递归，DP，ACclass Solution: def minDistance(self, word1: str, word2: str) -&gt; int: seen = &#123;&#125; def LCS(X, Y, i, j): if (i, j) in seen: return seen[(i, j)] else: if i == -1 or j == -1: seen[(i, j)] = 0 return seen[(i, j)] if X[i] == Y[j]: seen[(i, j)] = LCS(X, Y, i - 1, j - 1) + 1 return seen[(i, j)] else: seen[(i, j)] = max(LCS(X, Y, i - 1, j), LCS(X, Y, i, j - 1)) return seen[(i, j)] word1 = list(word1) word2 = list(word2) return len(word1) + len(word2) - 2 * LCS(word1, word2, len(word1) - 1, len(word2) - 1)# 3: 优化memo的DP，二维表class Solution: def minDistance(self, word1: str, word2: str) -&gt; int: m = len(word1) n = len(word2) memo = [[0] * (n + 1) for i in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: memo[i][j] = memo[i - 1][j - 1] + 1 else: memo[i][j] = max(memo[i - 1][j], memo[i][j - 1]) return m + n - 2 * memo[-1][-1]# 4: 进一步优化DP，两个数组，bestclass Solution: def minDistance(self, word1: str, word2: str) -&gt; int: if len(word1) &lt; len(word2): pass else: word1, word2 = word2, word1 s, l = len(word1), len(word2) memo = [[0] * (l + 1), [0] * (l + 1)] for i in range(s): for j in range(1, l + 1): if word1[i] == word2[j - 1]: memo[1][j] = memo[0][j - 1] + 1 else: memo[1][j] = max(memo[0][j], memo[1][j - 1]) memo[0], memo[1] = memo[1], memo[0] return s + l - 2 * memo[0][-1]# 5: 若要追溯子序列，在3的基础上增加一个标记memo. 本代码来自网上def find_lcseque(X, Y): m = len(X) n = len(Y) L = [[0] * (n + 1) for i in range(m + 1)] B = [[&quot;D&quot;] * (n + 1) for i in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: L[i][j] = 0 if i == 0: B[i][j] = &quot;L&quot; else: B[i][j] = &quot;U&quot; elif X[i - 1] == Y[j - 1]: L[i][j] = L[i - 1][j - 1] + 1 else: if L[i - 1][j] &lt; L[i][j - 1]: L[i][j] = L[i][j - 1] B[i][j] = &quot;L&quot; else: L[i][j] = L[i - 1][j] B[i][j] = &quot;U&quot; return L, Bdef track_lcseque(X, Y, Track): result = [] start = (len(X) - 1, len(Y) - 1) if Track[-1][-1] == &quot;D&quot;: result.append(X[-1]) while start[0] or start[1]: next = Track[start[0]][start[1]] if next == &quot;D&quot;: start = (start[0] - 1, start[1] - 1) result.append(X[start[0]]) elif next == &quot;L&quot;: start = (start[0], start[1] - 1) else: start = (start[0] - 1, start[1]) return result[::-1]x = &apos;abdfg&apos;y = &apos;abcdfg&apos;l, b = find_lcseque(x, y)print(&quot;LCS：&quot;, end=&quot;&quot;)print(track_lcseque(x, y, b))print(&quot;LCS Len：&quot; + str(l[-1][-1])) Longest Common Subarray Problem: 最长公共子串，要求连续。Leetcode上原题：Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays. Example: Input: A: [1,2,3,2,1], B: [3,2,1,4,7], output: 3. Link: https://leetcode.com/problems/maximum-length-of-repeated-subarray/ Answer:1234567891011121314151617181920212223242526272829303132333435363738394041# Comment: 这一题和上一题最大的区别就是找出的序列要求连续。因此两者的区别也就集中在递归方程的变化上：本题仅仅要求继承对角线上的累积和即可class Solution: def findLength(self, word1, word2): if len(word1) &lt; len(word2): pass else: word1, word2 = word2, word1 s, l = len(word1), len(word2) memo = [[0] * (l + 1), [0] * (l + 1)] max_len = 0 for i in range(s): for j in range(1, l + 1): if word1[i] == word2[j - 1]: memo[1][j] = memo[0][j - 1] + 1 max_len = max(max_len, memo[1][j]) else: memo[1][j] = 0 memo[0], memo[1] = memo[1], memo[0] return max_len# 若要定位出位置，则需要加一个track变量。下面代码来自网上，不过区别不大def find_lcsubstr(X, Y): m = len(X) n = len(Y) L = [[0] * (n + 1) for i in range(m + 1)] max_length = 0 # 最长匹配的长度 p = 0 # 最长匹配对应在s1中的最后一位 for i in range(m): for j in range(n): if X[i] == Y[j]: L[i + 1][j + 1] = L[i][j] + 1 if L[i + 1][j + 1] &gt; max_length: max_length = L[i + 1][j + 1] p = i + 1 return X[p - max_length:p], max_lengthprint(find_lcsubstr(&apos;abcdfg&apos;, &apos;abdfg&apos;)) Longest Palindromic Subsequence Problem: 最长回文子序列。Leetcode原题：Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000. Example: Input “XABCBBACXA”, output 7 (“XABCBAX”) Link: https://leetcode.com/problems/longest-palindromic-subsequence/ Answer:1234567891011121314151617181920# Comment: 不能用LCSeq来解决，因为虽然可以返回最大回文子序列的值，但是不一定找对序列。比如“ABCAB”，最大回文子序列是ABA，但是它和它的reverse“BACBA”的最大公共子序列可以是“ACB”，这就不是一个回文子序列# 用区间型动态规划来进行查找class Solution: def longestPalindromeSubseq(self, s): l = len(s) memo = [[0] * l for i in range(l)] for ll in range(l): for i in range(l - ll - 1, -1, -1): # Bottom-up j = i + ll if j == i: memo[i][j] = 1 else: if s[i] == s[j]: memo[i][j] = memo[i + 1][j - 1] + 2 else: memo[i][j] = max(memo[i + 1][j], memo[i][j - 1]) return memo[0][-1] Longest Palindromic Subarray Problem: 最长回文子串。Leetcode原题：Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example: Input: “cbbd”, output: “bb”. Link: https://leetcode.com/problems/longest-palindromic-substring/ Answers:12345678910111213141516171819202122232425262728293031323334353637383940414243# Comemnt: 不能用LCSub来解决，因为回文串不一定是最大子串。比如说“aacbdcaa”，镜像的最大子串是“aac”，但是回文只有“aa”# 用区间型动态规划来修改最大子串的查找方法class Solution: def longestPalindrome(self, s): l = len(s) memo = [[0] * l for i in range(l)] max_len = 0 start = end = 0 for ll in range(l): # 长度从0到l for i in range(l - ll - 1, -1, -1): # Bottom-up j = i + ll if j == i: memo[i][j] = True elif j == i + 1: memo[i][j] = (s[i] == s[j]) else: memo[i][j] = (memo[i + 1][j - 1] and (s[i] == s[j])) if memo[i][j] and j - i + 1 &gt; max_len: max_len = j - i + 1 start, end = i, j return s[start:end + 1]# 另有一种Manacher算法，只需要O(n)：https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2def manacher(s0 : str) -&gt; list: T = &apos;$#&apos; + &apos;#&apos;.join(s0) + &apos;#@&apos; l = len(T) P = [0] * l R, C = 0, 0 for i in range(1,l-1): if i &lt; R: P[i] = min(P[2 * C - i], R - i) while T[i+(P[i]+1)] == T[i-(P[i]+1)]: P[i] += 1 if P[i] + i &gt; R: R = P[i] + i C = i return P Longest Increasing Subsequence Problem: 最长递增子序列。Leetcode: Given an unsorted array of integers, find the length of longest increasing subsequence. Example: Input: [10,9,2,5,3,7,101,18], output: 4. Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Link: https://leetcode.com/problems/longest-increasing-subsequence/ Answer:12345678910111213141516171819202122232425262728293031323334# Comment: 最自然想到的是定义DP标记函数为L(n)，表示从1到n区间内的最长递增子序列长度。但是这样带来的问题是，当新的子序列不延续前面的子序列，而是从n+1处重新开始时，无法完成递归调用。所以需要把标记函数定义改为：从1到n区间内，使用了nums[n]的，最长递增子序列长度。因此，L(n) = 1 + max&#123;L(j), j from 1 to n - 1 &amp; nums[j] &lt; nums[n]&#125;.class Solution: def lengthOfLIS(self, nums): l = len(nums) memo = [0] * l max_len = 0 for i in range(l): for j in range(i): if nums[j] &lt; nums[i]: memo[i] = max(memo[i], memo[j]) memo[i] += 1 max_len = max(max_len, memo[i]) return max_len# 如果需要记录LIS具体是什么，加pointers回溯# 更好的方法：上面的方法时间复杂度是O(n^2)，我们可以在第二重循环上用Binary Search来改进查找效率，整体复杂度就会从n^2降到nlognclass Solution: def lengthOfLIS(self, nums): tails = [0] * len(nums) size = 0 for x in nums: i, j = 0, size while i != j: m = (i + j) // 2 if tails[m] &lt; x: i = m + 1 else: j = m tails[i] = x size = max(i + 1, size) return size Longest Increasing Subarray Problem: 最长递增子串。Leetcode: Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray). Example: Input: [1,3,5,4,7], output: 3 Link: https://leetcode.com/problems/longest-continuous-increasing-subsequence/ Answer:12345678910111213141516class Solution: def findLengthOfLCIS(self, nums): l = len(nums) if l &lt;= 1: return l memo = [1] * l max_len = 0 for i in range(1, l): if nums[i - 1] &lt; nums[i]: memo[i] = memo[i - 1] + 1 max_len = max(max_len, memo[i]) return max_len 矩阵链问题 Problem: 给定一串数[a, b, c, d]，表示矩阵ab、矩阵bc、矩阵cd相乘，判断如何控制计算顺序以达到最小计算量。矩阵ab 乘 矩阵bc 的计算量为ab*c。 Example: Input [3, 1, 5, 8], output: (A1(A2A3)) Link: 不确定Leetcode上有没有 Answer:1234567891011121314151617181920212223242526272829303132333435# 区间型动态规划def MATRIX_CHAIN_ORDER(p): n = len(p) - 1 # n is 矩阵个数 m = [[0 for col in range(n + 1)] for row in range(n + 1)] # m[i][j] is 对应矩阵计算 最优值 s = [[0 for col in range(n + 1)] for row in range(n + 1)] # 分割点记录 for L in range(2, n + 1): # L为矩阵链长度,依次枚举 for i in range(1, n - L + 2): # n-L+1为最后一次枚举的矩阵链的起点 j = i + L - 1 # j为枚举的矩阵链的终点 m[i][j] = float(&apos;inf&apos;) # 超出枚举的矩阵链计算量设为无穷大 for k in range(i, j): # k is 分割点，枚举 q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j] if q &lt; m[i][j]: m[i][j] = q # 新的最小值 s[i][j] = k # 分割点记录 print(&quot;最优路径：&quot;, end=&quot;&quot;) PRINT_OPTIMAL_PARENS(s, 1, n) return m, sdef PRINT_OPTIMAL_PARENS(s, i, j): if i == j: print(&quot;A&quot; + str(i), end=&apos;&apos;) else: print(&quot;(&quot;, end=&apos;&apos;) PRINT_OPTIMAL_PARENS(s, i, s[i][j]) PRINT_OPTIMAL_PARENS(s, s[i][j] + 1, j) print(&quot;)&quot;, end=&apos;&apos;)# testp = [3, 1, 5, 8]m, s = MATRIX_CHAIN_ORDER(p)print(&quot;\n最小代价：&quot; + str(max(sum(m, [])))) 取数游戏：头尾取数 Problem: Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins. Example: Input: [1, 5, 2], output: False. Explanation: Initially, player 1 can choose between 1 and 2. If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. Hence, player 1 will never be the winner and you need to return False. Link: https://leetcode.com/problems/predict-the-winner/ Answer:1234567891011121314151617181920212223242526# Comment: 与最大回文子串、矩阵链问题一样，是区间型动态规划class Solution: def PredictTheWinner(self, nums): l = len(nums) if l % 2 == 0: return True memo = [[0] * l for k in range(l)] sum_nums = 0 for ll in range(l): # 长度从0到l sum_nums += nums[ll] for i in range(l - ll): # i从头到l - 长度 j = i + ll if j == i: memo[i][j] = nums[i] elif j == i + 1: memo[i][j] = max(nums[i], nums[j]) else: left = min(memo[i + 1][j - 1], memo[i + 2][j]) + nums[i] right = min(memo[i][j - 2], memo[i + 1][j - 1]) + nums[j] memo[i][j] = max(left, right) return memo[0][-1] * 2 &gt;= sum_nums rod cutting：切钢管 Problem: 给定一根钢管，告知其每整数段的售价，问最大售价及最佳切割办法。 Example: l = [1, 2, 3, 4, 5, 6, 7, 8], p = [1, 5, 8, 9, 10, 17, 17, 20], 则最佳切割是在(2, 6)或(6, 2)处，总售价为5 + 17 = 22。 Link: 暂未找到 Answer: 123456789101112131415161718192021l = [1, 2, 3, 4, 5, 6, 7, 8]p = [1, 5, 8, 9, 10, 17, 17, 20]r = l[:]v = [p[0]] * len(l)for i in range(1, len(l)): for j in range(i): if p[j] + v[i - j - 1] &gt; v[i]: v[i] = p[j] + v[i - j - 1] r[i] = i - j if p[i] &gt; v[i]: v[i] = p[i] r[i] = i + 1print(&quot;最大价值：&quot; + str(v[-1]))res = []left = len(l)while left &gt; 0: res.append(r[left - 1]) left -= r[left - 1]print(&quot;最佳切割：&quot; + str(res))]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode-3-stock]]></title>
    <url>%2F2019%2F04%2F02%2FLeetcode-3-stock%2F</url>
    <content type="text"><![CDATA[整理Leetcode上关于股票买卖的一组问题，本质是用贪心/动态求解全局最优 Buy&amp;Sell 1 time Problem: Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example: Input [7,1,5,3,6,4], output 5. Buy at 1 and sell at 6. Link: https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ Answer:123456789101112# Comment: 用一个变量记录已经查看过的价格中最低的点，称为买入价格；用另一个变量记录局部最优解，它的构成要么是当前价格 - 买入价格，要么就是之前的某个价格 - 买入价格。由此我们只需要遍历一遍数组即可。class Solution: def maxProfit(self, prices): if not prices: return 0 minprice = prices[0] maxprofit = 0 for price in prices[1:]: minprice = min(minprice, price) maxprofit = max(maxprofit, price - minprice) return maxprofit Buy&amp;Sell unlimited time Problem: Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times). Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example: Input [7,1,5,3,6,4], output: 7. 1st buy at 1 and sell at 5, then 2nd buy at 3 and sell at 6. Total we get 7. Link: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ Answer:1234567891011# Comment: 本题与上一题的唯一区别就是可以买卖多次，所以局部最优解就从单次买卖的最优解变成累积和的最优解。我们不再需要记录买入价格，而是一旦当有盈利空间时，即当前价格 - 上一个价格 &gt; 0，就实行买卖。class Solution: def maxProfit(self, prices): if not prices: return 0 maxprofit = 0 for i in range(1, len(prices)): if prices[i] &gt; prices[i - 1]: maxprofit += prices[i] - prices[i - 1] return maxprofit Buy&amp;Sell at most 2 time Problem: Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example: Input: [3,3,5,0,0,3,1,4], output: 6. 1st buy on first 0 and sell at 3, 2nd buy on 1 and sell on 4. If we can buy as many as we could, we would add one buy-sell at 3 and 5, then the output will be 8. Link: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/ Answer:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Comment1: 因为买卖不能重叠（一定是买卖买卖），所以我们可以找到一个适当的点将数组分为两部分，在左右子数组各求出一次交易的最大值，即可得到本题的解。至于一次交易的最大值，就是和第一题的解法一致。# Comment2: 基于Comment1，最先想到的办法是扫描整个数组，然后分别计算扫描左右数组计算最大利润。这样做整个算法的复杂度是O(n^2)。# Comment3: 改进的办法是扫描两遍数组，并将每个切分点的利润保存下来。第一遍是从前往后扫描，这样就能把从第一天到第i天的最大利润记录下来。第二遍是从后往前扫描，这样用来记录第i天到最后一天的最大利润。最后取出两个组在同一个分界点时的最大利润和即可。class Solution: def maxProfit(self, prices): if len(prices) &lt; 2: return 0 pre_profit = [0] minprice = prices[0] maxprofit = 0 for price in prices[1:]: minprice = min(minprice, price) maxprofit = max(maxprofit, price - minprice) pre_profit.append(maxprofit) pos_profit = [0] minprice = prices[-1] maxprofit = 0 for price in prices[::-1][:-1]: minprice = max(minprice, price) maxprofit = max(maxprofit, minprice - price) pos_profit.insert(0, maxprofit) for i, profit in enumerate(pre_profit): maxprofit = max(maxprofit, profit + pos_profit[i]) return maxprofit# Comment4: 思路是我们在第一次交易的基础上，考虑第二次交易。买卖买卖是不重叠的，因此第二次交易面临的世界必然是第一次交易决策完成后的世界。如果第一次交易没有进行，那么第二次交易就变为第一次交易；否则，我们可以将第一次交易的情况映射到股价上，这表示我们可以动用第一次交易的收益进行第二次交易，即在第二次交易前，股价会全面下跌第一次交易的收益。完成映射后，我们再进行第二次交易，此时的情况已经与第一次交易完全一致。class Solution: def maxProfit(self, prices): if len(prices) &lt; 2: return 0 minPrice1, minPrice2 = prices[0], prices[0] maxProfit1, maxProfit2 = 0, 0 for price in prices[1:]: minPrice1 = min(price, minPrice1) maxProfit1 = max(maxProfit1, price - minPrice1) minPrice2 = min(minPrice2, price - maxProfit1) maxProfit2 = max(maxProfit2, price - minPrice2) return maxProfit2 Buy&amp;Sell at most k time Problem: Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example: Input: [3,2,6,5,0,3], k &gt;= 2, output: 7. 1st buy at 2 and sell at 6, 2nd buy at 0 and sell at 3. Link: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/ Answer:12345678910111213141516171819202122232425262728# Comment: 本题的关键是划定k的边界。对于一个长度为n的数组，买卖至多n // 2次。因此当k &gt;= (n // 2)时，本题退化为k可为无限次的Case II，只需要用不断贪心求累积和即可；否则，与给定上限次数的CaseI、III一致。class Solution: def maxProfit(self, k, prices): if k == 0: return 0 if len(prices) &lt; 2: return 0 if k &gt;= len(prices) // 2: maxprofit = 0 for i in range(1, len(prices)): if prices[i] &gt; prices[i - 1]: maxprofit += prices[i] - prices[i - 1] return maxprofit else: minPrices = [prices[0]] * k maxProfits = [0] * k for price in prices[1:]: minPrices[0] = min(price, minPrices[0]) maxProfits[0] = max(maxProfits[0], price - minPrices[0]) for i in range(1, k): minPrices[i] = min(minPrices[i], price - maxProfits[i - 1]) maxProfits[i] = max(maxProfits[i], price - minPrices[i]) return maxProfits[-1] Buy&amp;Sell unlimited time with cooldown limitation Problem: Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day) Example: Input: [1,2,3,0,2], output: 3. 1st buy at 1 and sell at first 2, 2nd buy at 0 and sell at second 2. You cannot 1st buy&amp;sell at (1, 3) and 2nd buy&amp;sell at (0, 2), as we need cooldown Link: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/ Answer:12345678910111213141516171819202122232425262728293031323334# Comment1: 本题与Case II类似，但实质上有着重大区别。因为我们无法连续买卖，所以不能继续用贪心求累积和的办法。这里改用动态规划。# Comment2: 首先我们明确在第i天，可做的操作有2种：买和卖。对于买，buy[i] = max(buy[i - 1], sell[i - 2] - prices[i])，即要不就是不买，要么就是用两天前卖出后的资金买入新的股票；对于卖，sell[i] = max(sell[i - 1], buy[i - 1] + prices[i])，要么就是不卖，要么就是把一天前买入的再卖出去。第一个式子已经包含了cooldown的逻辑，可见如果没有cooldown，那么直接用sell[i - 1]即可。class Solution: def maxProfit(self, prices): if len(prices) &lt; 2 : return 0 buy, sell, pre_buy, pre_sell = -prices[0], 0, 0, 0 for price in prices: pre_buy = buy buy = max(pre_sell - price, pre_buy) pre_sell = sell sell = max(pre_buy + price, pre_sell) return sell# 下面这一段是用同样的思路解决Case IIclass Solution: def maxProfit(self, prices): if len(prices) &lt; 2 : return 0 buy, sell, pre_buy = -prices[0], 0, 0 for price in prices: pre_buy = buy buy = max(sell - price, pre_buy) sell = max(pre_buy + price, sell) return sell Buy&amp;Sell unlimited time with fees Problem: Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.). Return the maximum profit you can make. Example: Input: prices = [1, 3, 2, 8, 4, 9], fee = 2, output: 8. ((8 - 1) - 2) + ((9 - 4) - 2) = 8. Link: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/ Answer:123456789101112131415# Comment: 我们采用与上面一样的思路，只不过每次买入时需要扣除费用。class Solution: def maxProfit(self, prices, fee): if len(prices) &lt; 2 : return 0 buy, sell, pre_buy = -prices[0], 0, 0 for price in prices: pre_buy = buy buy = max(sell - price, pre_buy) sell = max(pre_buy + price - fee, sell) return sell]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 2: path]]></title>
    <url>%2F2019%2F02%2F20%2FLeetcode-2-path%2F</url>
    <content type="text"><![CDATA[根据我个人的总结，Leetcode上Array类问题中，easy主要是解决一维数组的搜索和排序问题，技巧要点是用pointer和hash表来减少loop成本；medium则是上升到了二维数组、矩阵和图的层次，至于技巧还需要慢慢摸索。在这里总结一些典型的路径搜索问题。 Unique Paths Problem: A robot is located at the top-left corner of a m x n grid. The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid. How many possible unique paths are there? Example: m = 3, n = 2, return 3. From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -&gt; Right -&gt; Down; 2. Right -&gt; Down -&gt; Right; 3. Down -&gt; Right -&gt; Right Link: https://leetcode.com/problems/unique-paths/ Answer:12345# Comment: Easiest way is to use mathclass Solution: def uniquePaths(self, m, n): return int(math.factorial(m + n - 2) / math.factorial(m - 1) / math.factorial(n - 1)) Unique Paths II Problem: A robot is located at the top-left corner of a m x n grid. The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid. Now consider if some obstacles are added to the grids. How many unique paths would there be? Example: Input [[0,0,0], [0,1,0], [0,0,0]], then output should be 2. The Explanation is: there is one obstacle in the middle of the 3x3 grid above. There are two ways to reach the bottom-right corner: 1. Right -&gt; Right -&gt; Down -&gt; Down; 2. Down -&gt; Down -&gt; Right -&gt; Right Link: https://leetcode.com/problems/unique-paths-ii/ Answer:123456789101112131415161718192021222324252627282930# Comment: pure math cannot be use here, as the location of obstacles are random.# Fastest idea is recurrence, which is executable but with explosive complexity.# A better solution is dynamic programming.class Solution: def uniquePathsWithObstacles(self, obstacleGrid): m = len(obstacleGrid) n = len(obstacleGrid[0]) obstacleGrid[0][0] = 1 - obstacleGrid[0][0] for i in range(1, n): if not obstacleGrid[0][i]: obstacleGrid[0][i] = obstacleGrid[0][i-1] else: obstacleGrid[0][i] = 0 for i in range(1, m): if not obstacleGrid[i][0]: obstacleGrid[i][0] = obstacleGrid[i-1][0] else: obstacleGrid[i][0] = 0 for i in range(1, m): for j in range(1, n): if not obstacleGrid[i][j]: obstacleGrid[i][j] = obstacleGrid[i][j-1]+obstacleGrid[i-1][j] else: obstacleGrid[i][j] = 0 return obstacleGrid[-1][-1] Minimum Path Sum Problem: Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: Input [[1,3,1], [1,5,1], [4,2,1]] (In fact, this is an weighted version of Probelm Unique Path), output 7 (1-&gt;3-&gt;1-&gt;1-&gt;1). Link: https://leetcode.com/problems/minimum-path-sum/ Answer:12345678910111213141516171819# Recurrence: possible but low-effiency# Dynamic Programmingclass Solution: def minPathSum(self, grid): m = len(grid) n = len(grid[0]) for i in range(1, m): grid[i][0] += grid[i - 1][0] for i in range(1, n): grid[0][i] += grid[0][i - 1] for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i][j - 1], grid[i - 1][j]) return grid[-1][-1] Word Search Problem: Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: board = [[‘A’,’B’,’C’,’E’], [‘S’,’F’,’C’,’S’], [‘A’,’D’,’E’,’E’]], Given word = “ABCCED”, return true. Given word = “SEE”, return true. Given word = “ABCB”, return false. Link: https://leetcode.com/problems/word-search/ Answer:12345678910111213141516171819202122232425262728293031323334# 优化回溯算法，来自Submission中的最强者，真的很厉害from collections import Counterdirs = [(0, 1), (1, 0), (0, -1), (-1, 0)] # 移动方向class Solution: def exist(self, board, word): m, n = len(board), len(board[0]) bcnts = Counter(c for r in board for c in r) for w, w_cnt in Counter(word).items(): # 先通过个数检测是否不可能存在 if w not in bcnts or w_cnt &gt; bcnts[w]: return False def backtrack(i, j, index): if index == len(word) - 1: # 如果只有一个字母，即为True return True # 标记为已访问 board[i][j] = &apos;*&apos; for dx, dy in dirs: next_i, next_j = i + dx, j + dy # 先判断再进入，减少递归次数 if 0 &lt;= next_i &lt; m and 0 &lt;= next_j &lt; n and word[index + 1] == board[next_i][next_j] and backtrack( next_i, next_j, index + 1): return True board[i][j] = word[index] # 再把标记过的还原 return False for i in range(m): for j in range(n): if board[i][j] == word[0] and backtrack(i, j, 0): return True return False]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm]]></title>
    <url>%2F2019%2F02%2F02%2FAlgorithm%2F</url>
    <content type="text"><![CDATA[本文是为了2019年春季的Design &amp; Analysis of Algotirhm而撰写，目的是总结课程中学到的算法。 Sorting123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304import timeclass Sort: &quot;&quot;&quot; Class for all kinds of sorting algorithms implemented in Python3 Notes: if maxone - minone in the list &lt; nlogn, we can use counting sort else range k of the nums is &gt;&gt; nlong, we can use radix sort. Both Algos are O(n) if we need to sort for numbers in other number system, like bin or hex, we need to use Radix Sort if nums are very huge and cannot load at a time, we need to use heap sort with forward-method for building heaps &quot;&quot;&quot; def InsertSort(self, nums): &quot;&quot;&quot; :intro: insertion sort :param nums: unsorted nums (list) :return: sorted nums (list) &quot;&quot;&quot; sorted_nums = nums[:1] for num in nums[1:]: for sorted_num_index in range(len(sorted_nums) - 1, -1, -1): if sorted_nums[sorted_num_index] &gt; num: if sorted_num_index == 0: sorted_nums.insert(sorted_num_index, num) else: continue else: sorted_nums.insert(sorted_num_index + 1, num) break return sorted_nums def MergeSort(self, nums): &quot;&quot;&quot; :intro: merge sort :param nums: unsorted nums (list) :return: sorted nums (list) &quot;&quot;&quot; def divide(given_nums): &quot;&quot;&quot; :intro: dimidiate given array :param given_nums: given array (list) :return: two parts of dimidiated array (list) &quot;&quot;&quot; return given_nums[:(len(given_nums) // 2)], given_nums[(len(given_nums) // 2):] def merge(left_nums, right_nums): &quot;&quot;&quot; :intro: merge sorted arrays :param left_nums: one sorted array (list) :param right_nums: another sorted array (list) :return: merged sorted array (list) &quot;&quot;&quot; merged_nums = [] l = r = 0 for i in range(len(left_nums) + len(right_nums)): if left_nums[l] &lt; right_nums[r]: merged_nums.append(left_nums[l]) l += 1 else: merged_nums.append(right_nums[r]) r += 1 if l == len(left_nums): merged_nums += right_nums[r:] break if r == len(right_nums): merged_nums += left_nums[l:] break return merged_nums if len(nums) &gt;= 2: nums_l, nums_r = divide(nums) nums_l = self.MergeSort(nums_l) nums_r = self.MergeSort(nums_r) return merge(nums_l, nums_r) return nums def HeapSort(self, nums): &quot;&quot;&quot; :intro: heap sort # 从小到大排需建立大根堆，从大到小需建立小根堆，或者reverse一下 :param nums: unsorted array :return: sorted array &quot;&quot;&quot; def adjust(nums, start, end): &quot;&quot;&quot; :intro: adjust given heap, which contained in a given nums :param nums: given nums :param start: the startpoint of heap :param end: the endpoint of heap :return: adjusted heap, which contained in the previous nums &quot;&quot;&quot; root = start left = 2 * start + 1 right = 2 * start + 2 if left &lt; end and nums[left] &lt; nums[root]: root = left if right &lt; end and nums[right] &lt; nums[root]: root = right if root != start: nums[start], nums[root] = nums[root], nums[start] adjust(nums, root, end) return nums length = len(nums) for i in range(length // 2 - 1, -1, -1): adjust(nums, i, length) for j in range(length - 1, -1, -1): nums[0], nums[j] = nums[j], nums[0] adjust(nums, 0, j) return nums[::-1] def CountingSort(self, nums): &quot;&quot;&quot; :intro: Counting sort for n integers, where value range k of n &lt; nlogn :param nums: unsorted array :return: sorted array &quot;&quot;&quot; minone = min(nums) gap = 1 - minone # 把负数填充成大于等于1的正数 maxone = max(nums) sorted_nums = [0] * len(nums) countings = [0] * (maxone - minone + 1) for num in nums: countings[num + gap - 1] += 1 summings = [sum(countings[:c + 1]) for c in range(len(countings))] for num in nums[::-1]: sorted_nums[summings[num + gap - 1] - 1] = num summings[num + gap - 1] -= 1 return sorted_nums def RadixSort(self, nums): &quot;&quot;&quot; :intro: Radix sort for n integers, where value range k of n can be far bigger than nlogn :param nums: unsorted array :return: sorted array &quot;&quot;&quot; # Radix Sort必须使用stable的算法来进行每一个数位上的排序，同时数位上数的范围最多是0～9，远小于n，所以最好用Counting Sort # 这里建立一个特殊的counting sort，是为了返回原list中元素的index，方便定位 def CountingSort_withindex(nums): &quot;&quot;&quot; :intro: Counting sort and kept original indexes :param nums: unsorted array :return: sorted array &quot;&quot;&quot; minone = min(nums, key=lambda x: x[1])[1] gap = 1 - minone # 把负数填充成大于等于1的正数 maxone = max(nums, key=lambda x: x[1])[1] sorted_nums = [0] * len(nums) countings = [0] * (maxone - minone + 1) for num in nums: countings[num[1] + gap - 1] += 1 summings = [sum(countings[:c + 1]) for c in range(len(countings))] for num in nums[::-1]: sorted_nums[summings[num[1] + gap - 1] - 1] = (num[0], num[1]) summings[num[1] + gap - 1] -= 1 return sorted_nums minone = min(nums) gap = -minone # 把负数填充成大于等于0的数 nums = [num + gap for num in nums] length = len(str(max(nums))) l = 0 digits = [(n, nums[n] // (10 ** l) % 10) for n in range(len(nums))] while l &lt; length: c_digits = CountingSort_withindex(digits) l += 1 digits = [(i, nums[i] // (10 ** l) % 10) for i, d in c_digits] return [nums[i] - gap for i, d in digits] def QuickSort(self, nums): &quot;&quot;&quot; :intro: Quick Sort for n numbers :param nums: unsorted array :return: sorted array &quot;&quot;&quot; if len(nums) &lt;= 1: return nums else: pivot = nums.pop() s1, s2 = [], [] for num in nums: if num &lt; pivot: s1.append(num) else: s2.append(num) return self.QuickSort(s1) + [pivot] + self.QuickSort(s2) def QuickSort_inplace_1(self, nums, p, r): &quot;&quot;&quot; :intro: Quick Sort for n numbers (in place version 1: keep move smaller elements front of the pivot) :param nums: unsorted array :param p: start position of sorting any part of the whole array :param r: end position of sorting any part of the whole array :return: sorted array &quot;&quot;&quot; def Partition(nums, p, r): &quot;&quot;&quot; :intro: Partition for given array, by keeping move smaller elements front of the pivot :param nums: any array :param p: start position of targeted array waiting to be partitioned :param r: end position of targeted array waiting to be partitioned :return: elements in range(p, r) will be partitioned by pivot with smaller before the pivot and larger after &quot;&quot;&quot; pivot = nums[p] pivot_index = p for i in range(p + 1, r + 1): current = nums[i] if current &lt; pivot: nums.pop(i) nums.insert(pivot_index, current) pivot_index += 1 return pivot_index if p &lt; r: q = Partition(nums, p, r) self.QuickSort_inplace_1(nums, p, q - 1) self.QuickSort_inplace_1(nums, q + 1, r) def QuickSort_inplace_2(self, nums, p, r): &quot;&quot;&quot; :intro: Quick Sort for n numbers (in place version 2: two pointers searching) :param nums: unsorted array :param p: start position of sorting any part of the whole array :param r: end position of sorting any part of the whole array :return: sorted array &quot;&quot;&quot; def Partition(nums, p, r): &quot;&quot;&quot; :intro: Partition for given array, by using two pointers to track adjusting pairs and swap :param nums: any array :param p: start position of targeted array waiting to be partitioned :param r: end position of targeted array waiting to be partitioned :return: elements in range(p, r) will be partitioned by pivot with smaller before the pivot and larger after &quot;&quot;&quot; pivot = nums[p] while p &lt; r: while p &lt; r and nums[r] &gt;= pivot: r -= 1 nums[p] = nums[r] while p &lt; r and nums[p] &lt;= pivot: p += 1 nums[r] = nums[p] nums[p] = pivot return p if p &lt; r: q = Partition(nums, p, r) self.QuickSort_inplace_2(nums, p, q - 1) self.QuickSort_inplace_2(nums, q + 1, r)sorting = Sort()unsorted_nums = [1, 22, 1, 1, 2, -3, 5, -10, -2, 0, 7, 19, 4, 99, -3, -10, 0]start = time.time()print(sorting.InsertSort(unsorted_nums))stop1 = time.time()print((stop1 - start) * 1000)print(sorting.MergeSort(unsorted_nums))stop2 = time.time()print((stop2 - stop1) * 1000)# Heap sort is an in-place operation, so we need to rebuild the unsorted array belowprint(sorting.HeapSort(unsorted_nums))stop3 = time.time()print((stop3 - stop2) * 1000)unsorted_nums = [1, 22, 1, 1, 2, -3, 5, -10, -2, 0, 7, 19, 4, 99, -3, -10, 0]print(sorting.CountingSort(unsorted_nums))stop4 = time.time()print((stop4 - stop3) * 1000)print(sorting.RadixSort(unsorted_nums))stop5 = time.time()print((stop5 - stop4) * 1000)# The extra space quick sort will delete the tail of original array, so we need to rebuild the unsorted array belowprint(sorting.QuickSort(unsorted_nums))stop6 = time.time()print((stop6 - stop5) * 1000)# The in-place quick sort do in-place operation, so we need to rebuild the unsorted array belowunsorted_nums = [1, 22, 1, 1, 2, -3, 5, -10, -2, 0, 7, 19, 4, 99, -3, -10, 0]sorting.QuickSort_inplace_1(unsorted_nums, 0, len(unsorted_nums) - 1)print(unsorted_nums)stop7 = time.time()print((stop7 - stop6) * 1000)# The in-place quick sort do in-place operation, so we need to rebuild the unsorted array belowunsorted_nums = [1, 22, 1, 1, 2, -3, 5, -10, -2, 0, 7, 19, 4, 99, -3, -10, 0]sorting.QuickSort_inplace_2(unsorted_nums, 0, len(unsorted_nums) - 1)print(unsorted_nums)stop8 = time.time()print((stop8 - stop7) * 1000)unsorted_nums = [1, 22, 1, 1, 2, -3, 5, -10, -2, 0, 7, 19, 4, 99, -3, -10, 0]# Wait for next sort... Search123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138import timeclass Search: &quot;&quot;&quot; Class for all searching algorithms implemented in Python 3 &quot;&quot;&quot; def BinarySearch(self, sorted_nums, start, end, target): &quot;&quot;&quot; :intro: binary search for a given target in a sorted array :param sorted_nums: sorted array :param start: start index :param end: end index :param target: given number :return: index of given number &quot;&quot;&quot; if start &gt; end: return &quot;No such target&quot; mid = (start + end) // 2 if target == sorted_nums[mid]: return mid elif target &lt; sorted_nums[mid]: return self.BinarySearch(sorted_nums, start, mid - 1, target) elif target &gt; sorted_nums[mid]: return self.BinarySearch(sorted_nums, mid + 1, end, target) def Search2nd(self, unsorted_nums): &quot;&quot;&quot; :intro: find 2nd biggest number in an unsorted array :param unsorted_nums: unsorted array :return: 2nd biggest number &quot;&quot;&quot; mmmone = unsorted_nums[-1] maxone = ma2one = 0 n = len(unsorted_nums) kdict = &#123;&#125; while n &gt; 1: next_nums = [] for i in range(n // 2): maxone = max(unsorted_nums[2 * i], unsorted_nums[2 * i + 1]) minone = min(unsorted_nums[2 * i], unsorted_nums[2 * i + 1]) next_nums.append(maxone) if maxone in kdict: kdict[maxone].append(minone) else: kdict[maxone] = [minone] unsorted_nums = next_nums n = len(unsorted_nums) for c in kdict[maxone]: ma2one = max(ma2one, c) if len(unsorted_nums) % 2 == 0: pass else: if mmmone &gt; maxone: return maxone elif mmmone &gt; ma2one: return mmmone else: pass return ma2one def SearchK_deterministic(self, unsorted_nums, k): &quot;&quot;&quot; :intro: find k-th smallest number in an unsorted and distinct array via deterministic pivot :param unsorted_nums: unsorted array :param k: k-th smallest index :return: k-th smallest number &quot;&quot;&quot; group = 5 length = len(unsorted_nums) // group ms = [sorted(unsorted_nums[group * i: group * i + group], reverse=True) for i in range(length)] # 按五个分为一组 ms.append(sorted(unsorted_nums[group * length:], reverse=True)) # 最后一组可以小于5 mm = [s[len(s) // 2] for s in ms if s != []] # 每组的中位数 if len(mm) &gt; 1: # 中位数的中位数作为m，递归实现 m = self.SearchK_deterministic(mm, len(mm) // 2) else: m = mm[0] s1 = [] s2 = [] for num in unsorted_nums: if num &lt; m: s1.append(num) elif num &gt; m: s2.append(num) length = len(s1) if length + 1 == k: return m elif length &gt;= k: return self.SearchK_deterministic(s1, k) else: return self.SearchK_deterministic(s2, k - length - 1) def SearchK_randomized(self, unsorted_nums, k): &quot;&quot;&quot; :intro: find k-th smallest number in an unsorted and distinct array via randomly pivot :param unsorted_nums: unsorted array :param k: k-th smallest index :return: k-th smallest number &quot;&quot;&quot; from random import sample r = sample(range(len(unsorted_nums)), 1)[0] # 随机选一个数 s1 = [] s2 = [] for num in unsorted_nums: if num &lt; unsorted_nums[r]: s1.append(num) elif num &gt; unsorted_nums[r]: s2.append(num) length = len(s1) if length + 1 == k: return unsorted_nums[r] elif length &gt;= k: return self.SearchK_randomized(s1, k) else: return self.SearchK_randomized(s2, k - length - 1)search = Search()sorted_nums = [-10, -10, -3, -3, -2, 0, 0, 1, 1, 1, 2, 4, 5, 7, 19, 22, 99]unsorted_nums = [1, 22, 1, 1, 2, -3, 5, -10, -2, 0, 7, 19, 4, 99, -3, -10, 0]unsorted_distinct_nums = [1, 22, 2, -3, 5, -10, -2, 0, 7, 19, 4, 99]start = time.time()print(search.BinarySearch(sorted_nums, 0, len(sorted_nums) - 1, 5))stop1 = time.time()print((stop1 - start) * 1000)print(search.Search2nd(unsorted_nums))stop2 = time.time()print((stop2 - stop1) * 1000)print(search.SearchK_deterministic(unsorted_distinct_nums, 10))stop3 = time.time()print((stop3 - stop2) * 1000)print(search.SearchK_randomized(unsorted_distinct_nums, 10))stop4 = time.time()print((stop4 - stop3) * 1000) Binary Search Tree12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394# 代码来自：https://blog.csdn.net/u010089444/article/details/70854510class Node: def __init__(self, data): self.data = data self.lchild = None self.rchild = Noneclass BST: def __init__(self, node_list): self.root = Node(node_list[0]) for data in node_list[1:]: self.insert(data) def search(self, node, parent, data): if node is None: return False, node, parent if node.data == data: return True, node, parent if node.data &gt; data: return self.search(node.lchild, node, data) else: return self.search(node.rchild, node, data) def insert(self, data): flag, n, p = self.search(self.root, self.root, data) if not flag: new_node = Node(data) if data &gt; p.data: p.rchild = new_node else: p.lchild = new_node def delete(self, data): flag, n, p = self.search(self.root, self.root, data) if flag is False: print(&quot;无该关键字，删除失败&quot;) else: if n.lchild is None: # 如果右子树为空，直接往上继承 if n == p.lchild: p.lchild = n.rchild else: p.rchild = n.rchild del n elif n.rchild is None: # 如果左子树为空，直接往上继承 if n == p.lchild: p.lchild = n.lchild else: p.rchild = n.lchild del n else: # 左右子树均不为空 pre = n.rchild if pre.lchild is None: n.data = pre.data n.rchild = pre.rchild del pre else: next = pre.lchild # 往右一个节点，然后一直找到最左下角 while next.lchild is not None: pre = next next = next.lchild n.data = next.data pre.lchild = next.rchild # 把next拿走后，因为next必定没有左孩子，故直接让上一层的左孩子继承next的右子树 del next def preOrderTraverse(self, node): if node is not None: print(node.data, end=&quot;, &quot;) self.preOrderTraverse(node.lchild) self.preOrderTraverse(node.rchild) return &quot;End&quot; def inOrderTraverse(self, node): if node is not None: self.inOrderTraverse(node.lchild) print(node.data, end=&quot;, &quot;) self.inOrderTraverse(node.rchild) return &quot;End&quot; def postOrderTraverse(self, node): if node is not None: self.postOrderTraverse(node.lchild) self.postOrderTraverse(node.rchild) print(node.data, end=&quot;, &quot;) return &quot;End&quot;a = [3, 1, 8, 4, 6, 5, 7]bst = BST(a) # 创建二叉查找树print(bst.inOrderTraverse(bst.root)) # 中序遍历，等于排序bst.delete(3)print(bst.inOrderTraverse(bst.root)) # 中序遍历，等于排序 Graph123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778graph = &#123; &quot;A&quot;: [&quot;B&quot;, &quot;C&quot;], &quot;B&quot;: [&quot;A&quot;, &quot;C&quot;, &quot;D&quot;], &quot;C&quot;: [&quot;A&quot;, &quot;B&quot;, &quot;D&quot;, &quot;E&quot;], &quot;D&quot;: [&quot;B&quot;, &quot;C&quot;, &quot;E&quot;, &quot;F&quot;], &quot;E&quot;: [&quot;C&quot;, &quot;D&quot;], &quot;F&quot;: [&quot;D&quot;]&#125;def BFS(graph, start, end): &quot;&quot;&quot; :intro: using BFS to find shortest path between two given points in a graph :param graph: the graph :param start: the start endpoint :param end: the destination endpoint :return: the path &quot;&quot;&quot; if start not in graph or end not in graph: return &quot;Wrong endpoints&quot; else: seen = set(start) queue = graph[start][::] path = &#123;v: start for v in queue&#125; while queue: curr = queue.pop(0) seen.add(curr) if curr != end: queue += [e for e in graph[curr] if e not in seen] path.update(&#123;e: curr for e in graph[curr] if e not in path and e not in seen&#125;) else: break if end in path: track = end way = [] while track in path: way.append(track) track = path[track] return [start] + way[::-1] else: return &quot;No path&quot;def DFS(graph, start, end): &quot;&quot;&quot; :intro: using DFS to find shortest path between two given points in a graph :param graph: the graph :param start: the start endpoint :param end: the destination endpoint :return: the path &quot;&quot;&quot; if start not in graph or end not in graph: return &quot;Wrong endpoints&quot; else: seen = set(start) stack = graph[start][::] path = &#123;v: start for v in stack&#125; while stack: curr = stack.pop() seen.add(curr) if curr != end: stack += [e for e in graph[curr] if e not in seen] path.update(&#123;e: curr for e in graph[curr] if e not in path and e not in seen&#125;) else: break if end in path: track = end way = [] while track in path: way.append(track) track = path[track] return [start] + way[::-1] else: return &quot;No path&quot;print(BFS(graph, &quot;A&quot;, &quot;F&quot;))print(DFS(graph, &quot;A&quot;, &quot;F&quot;))]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 1: sum]]></title>
    <url>%2F2019%2F01%2F15%2FLeetcode-1-sum%2F</url>
    <content type="text"><![CDATA[整理了一部分Leetcode上关于两个及两个以上数求和的问题 Two Sum Problem: Given an array of integers, return indices of the two numbers such that they add up to a specific target. Example: Given nums = [2, 7, 11, 15], target = 9. Return [0, 1] Link: https://leetcode.com/problems/two-sum/ Answer: 123456789101112# Comments: time complexity of searching in dict is O(1), since dict in python is organized by hashclass Solution(object): def twoSum(self, nums, target): if len(nums) &lt;= 1: return False buff_dict = &#123;&#125; for i in range(len(nums)): if nums[i] in buff_dict: return [buff_dict[nums[i]], i] else: buff_dict[target - nums[i]] = i Two Sum, Input array is sorted Problem: Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Example: Given numbers = [2,7,11,15], target = 9. Return [1,2] Link: https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/ Answer 1: 12345678910111213141516class Solution: # 两个指针往中间移动，较快 def twoSum(self, numbers, target): &quot;&quot;&quot; :type numbers: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; l, r = 0, len(numbers) - 1 while l &lt; r: s = numbers[l] + numbers[r] if s == target: # 如果等于，直接返回 return [l + 1, r + 1] elif s &lt; target: # 如果小于，左边指针右移 l += 1 else: # 如果大于，右边指针左移 r -= 1 Answer 2: 123456789101112class Solution: # 哈希表，最快 def twoSum(self, numbers, target): &quot;&quot;&quot; :type numbers: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; dic = &#123;&#125; for i, num in enumerate(numbers): # = for i in range(len(numbers)) if target - num in dic: return [dic[target - num] + 1, i + 1] dic[num] = i Three Sum Problem: Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4], return [[-1, 0, 1], [-1, -1, 2]] Link: https://leetcode.com/problems/3sum/ Answer, copied from here:12345678910111213141516171819202122# Comment 1: 最容易想到的是基于Two Sum的两重循环加hash，但要想到先排序是比较难的class Solution(object): def threeSum(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; if len(nums) &lt; 3: return [] nums.sort() res = set() for i, v in enumerate(nums[:-2]): if i &gt;= 1 and v == nums[i-1]: continue d = &#123;&#125; for x in nums[i+1:]: if x not in d: d[-v-x] = 1 else: res.add((v, -v-x, x)) return list(map(list, res)) Three Sum Closest Problem: Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. Example: Given array nums = [-1, 2, 1, -4], and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). Link: https://leetcode.com/problems/3sum-closest/ Answer:12345678910111213141516171819202122232425262728293031323334353637# Comment 1: can&apos;t find exact source# Comment 2: based on Three Sum, with two pointersclass Solution: def threeSumClosest(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; if len(nums) &lt; 3: return [] nums.sort() closest = None closest_distance = float(&apos;inf&apos;) for i in range(len(nums[:-2])): if i &gt; 0 and nums[i] == nums[i-1]: continue l, r = i + 1, len(nums) - 1 while l &lt; r: current_sum = nums[i] + nums[l] + nums[r] if current_sum &lt; target: l += 1 elif current_sum &gt; target: r -= 1 elif current_sum == target: return target current_distance = abs(current_sum - target) if current_distance &lt; closest_distance: closest = current_sum closest_distance = current_distance return closest Four Sum Problem: Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. The solution set must not contain duplicate quadruplets. Example: Given array nums = [1, 0, -1, 0, -2, 2], and target = 0. A solution set is: [[-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] Link: https://leetcode.com/problems/4sum/ Answer:12345678910111213141516171819202122232425262728293031# Comment 1: can&apos;t find exact source# Comment 2: 我写了一个基于Three Sum + 一重循环的，能提交，但毕竟还是多了一个量级# Comment 3: 另一种思路是把Four Sum当成两个Two Sum，但并不是迭代。可以先两两计算所有可能的值，然后匹配成4元组，即如下class Solution: def fourSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[List[int]] &quot;&quot;&quot; if not nums or len(nums) &lt; 4: return [] nums.sort() sum_to_ix = &#123;&#125; ans = set() m = len(nums) for i in range(m): for j in range(i+1,m): two_sum = nums[i] + nums[j] key_list = sum_to_ix.keys() if two_sum not in key_list: sum_to_ix[two_sum] = [[i,j]] else: sum_to_ix[two_sum].append([i,j]) if target-two_sum in key_list: for idx in sum_to_ix[target-two_sum]: if i not in idx and j not in idx: ans.add(tuple(sorted([nums[idx[0]],nums[idx[1]],nums[i],nums[j]]))) return list(ans) Combination Sum Problem: Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. The solution set must not contain duplicate combinations. Example: Given candidates = [2,3,6,7], target = 7. A solution set is: [[7], [2,2,3]]. Link: https://leetcode.com/problems/combination-sum/ Answer, copied from here 123456789101112131415161718class Solution(object): def combinationSum(self, candidates, target): solution = [] def dfs(running, running_sum, ind): for i in range(ind, len(candidates)): next_sum = running_sum + candidates[i] if next_sum &lt; target: dfs(running + [candidates[i]], next_sum, i) elif next_sum == target: solution.append(running + [candidates[i]]) else: continue dfs([], 0, 0) return solution Appendix: 补充一段Python实现BFS和DFS的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748graph = &#123; &quot;A&quot;: [&quot;B&quot;, &quot;C&quot;], &quot;B&quot;: [&quot;A&quot;, &quot;C&quot;, &quot;D&quot;], &quot;C&quot;: [&quot;A&quot;, &quot;B&quot;, &quot;D&quot;, &quot;E&quot;], &quot;D&quot;: [&quot;B&quot;, &quot;C&quot;, &quot;E&quot;, &quot;F&quot;], &quot;E&quot;: [&quot;C&quot;, &quot;D&quot;], &quot;F&quot;: [&quot;D&quot;]&#125;def BFS(graph, s): &quot;&quot;&quot; :param graph: graph :param s: startpoint :return: BFS path &quot;&quot;&quot; queue = [] queue.append(s) seen = set() seen.add(s) while len(queue) &gt; 0: vertex = queue.pop(0) nodes = graph[vertex] for w in nodes: if w not in seen: queue.append(w) seen.add(w) print(vertex)def DFS(graph, s): &quot;&quot;&quot; :param graph: graph :param s: startpoint :return: DFS path &quot;&quot;&quot; stack = [] stack.append(s) seen = set() seen.add(s) while len(stack) &gt; 0: vertex = stack.pop() nodes = graph[vertex] for w in nodes: if w not in seen: stack.append(w) seen.add(w) print(vertex) Subarray Sum Equals K Problem: Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example: Input nums = [1,1,1] and k = 2, output 2. Link: https://leetcode.com/problems/subarray-sum-equals-k/ Answer:123456789101112131415# Comment: 从0到j的累积和-从0到i的累积和=k，则i到j的和为k --》转化为Two Sumclass Solution: def subarraySum(self, nums, k): count = 0 if not nums: return count mapping = &#123;0: 1&#125; cur_sum = 0 for i in range(len(nums)): cur_sum += nums[i] if cur_sum - k in mapping: count += mapping[cur_sum - k] mapping[cur_sum] = mapping.get(cur_sum, 0) + 1 return count Valid Triangle Number Problem: Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle. Example: Input nums = [2, 2, 3, 4], output 3 (223, 234, 234). Link: https://leetcode.com/problems/valid-triangle-number/ Answer12345678910111213141516# Comment: 3指针法。先排序，然后一个指针定位长边，两个指针（称为左右指针）在该指针的左侧搜寻可能的组合。左指针从index=0处出发，右指针从index=i-1处出发。当两短边相加大于长边时，计数right - left（中间所有元素与right的和势必都可以大于长边）同时右指针左移一位来使短边和下降；反之，左指针右移一位使短边和上升class Solution: def triangleNumber(self, nums: List[int]) -&gt; int: nums.sort() count = 0 for i in range(2, len(nums)): left = 0 right = i - 1 while left &lt; right: if nums[left] + nums[right] &gt; nums[i]: count += right - left right -= 1 else: left += 1 return count Subarray Product Less Than K Problem: Your are given an array of positive integers nums. Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k. Example: Input: nums = [10, 5, 2, 6], k = 100; output 8. Link: https://leetcode.com/problems/subarray-product-less-than-k/ Answer:1234567891011121314151617# Comment1: 这类找子串的问题，最方便的就是用指针设置滑动窗口。部分子序列问题，也可以先排序，然后再转化为子串问题# Comment2: 2指针法。用O(1)空间记录当前的积，右指针从index=0处不断右移，积不断变大。当积大于目标值时，左指针从index=0处右移，积不断变小。计数就等于左右指针间距离之和。需要注意，由于nums全是正数，所以不存在任何组合积&lt;=1class Solution: def numSubarrayProductLessThanK(self, nums, k): if k &lt;= 1: return 0 curr_prod = 1 l = 0 count = 0 for r, num in enumerate(nums): curr_prod *= num while curr_prod &gt;= k: curr_prod //= nums[l] l += 1 count += r - l + 1 return count]]></content>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Does money make people happy?]]></title>
    <url>%2F2019%2F01%2F11%2FDoes-money-make-people-happy%2F</url>
    <content type="text"><![CDATA[秋季学期的Applied Data Science课程要求做一个和城市数据有关的期末项目。我们小组设计了一个非常有哲学含义的项目：Does money make people happy? 思考 这是一个立意比较高、实践难度比较大的项目 为什么这么说？首先我们把这个命题翻译成机器学习用语就是：以能够描述金钱的变量作为特征，以能够描述人们心里高兴程度的变量为目标值，通过相关性分析或机器学习模型，能否发现这些特征与目标值之间的一定关系？ 那么问题来了，什么变量可以描述金钱？什么变量可以描述人们心里的高兴程度呢？ 思路 特征值：我们认为包含在人口普查数据中的一系列经济社会数据可以描述金钱，或者说可支配收入水平。此外，我们也思考是否可以扩大“金钱”这个词的内涵，比如如果一个人住在地段比较好、房价比较贵的地方，周边服务设施多，那么可能ta的心情就会比较好，又比如一个人住的房子很大、很新，那么可能ta的心情就会更好。因此结合数据可获得的难易程度，我们选取了两组数据作为特征。一是全部540+的美国人口普查经济指标，其中包含每个统计区的平均收入、平均寿命预期等等可能的因变量；二是每个统计区的中位数收入、平均房价和地价。这里的统计区是以邮编划分的。 目标值：自然语言处理里有一门技术叫情感分析，主要思想是利用基于大规模统计的情感词典来量化文本所体现的情绪。比如对于“今天天气真好！”这样一句话，可能量化为(正面：0.9，中性：0.2，负面：-0.1)的情感得分。至此，我们只需要寻找能够反映人们情绪的载体–大规模文本即可。那么什么是最接近的呢？自然是每天产生大量内容的社交媒体。 数据 ACS：基于邮编的纽约市人口普查经济指标 PLUTO：纽约市房价地价数据。值得感慨的是美国人把这个数据开源到了每栋房屋的级别，坐标、用地类型和价格信息都很详细，数据建设是真的好。考虑到居住人口比移动人口有更好的参考价值，我们根据用地类型筛选出了居住用地，计算了每个邮编区域的平均地价和房价。此外，从ACS数据中选取了最有代表性的中位数收入数据补充到这一组特征中 情绪：我们使用Twitter API收集了纽约市内从2018年10月24日20点到2018年11月26日19点的带有打卡信息的42万tweets，其中打卡信息就是发推地点的准确经纬度坐标。之后，我们筛选了发送时间在早8点之前和晚7点之后的数据–因为它们更可能来自居住地。紧接着，我们对全部文本进行自然语言处理，包括分词、停用词处理、词形还原和情感分量化等过程。量化时借鉴了两部词典，分别是英文词情感词典和emoji情感词典。至于我们为什么要特别处理emojis，是因为在某些情况下表情符号可以传达文字无法传达的情绪，请看下图： 实验 基于以上数据，我们做了相关性检测、回归和分类算法的测试 试验结果、代码和非常有趣的诸多GIS图像，请查看本项目 感想 第一次自己设计一个有意思的社会学命题，并尝试用数据科学和机器学习的方法去解决问题 存在很多问题，特别是人口普查的样本和推特样本严重不一致 但还是很自豪，并希望继续努力 放一张纽约市积极情绪图做一纪念：]]></content>
      <tags>
        <tag>Data mining</tag>
        <tag>Sentiment analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SMP CUP 2018]]></title>
    <url>%2F2018%2F07%2F12%2FSMP-CUP-2018%2F</url>
    <content type="text"><![CDATA[时间太快啦，转眼就一年了，又到了SMP CUP 2018的时候。今年比赛和去年略有不同，去年是一份数据三个任务，今年则是一个任务独享一份数据。任务一文本分类，任务三文本溯源。 比赛简介 任务一文本分类：给定一篇短文，判断是人类作者、自动摘要、机器翻译和机器作者中的哪一种，详见官网 任务三文本溯源：给定一个句子，判断是否复制或改编(删减/摘要/替换/重排等)于其它的句子，详见官网 数据样例 任务一：ID12345 ||| 方法通过文献研究、药物实测、炮制方法、方药配伍、煎服方法、安全性及临床用药特点等方面考证《伤寒论》药物剂量。 任务三：自动摘要 ||| 自动摘要生成的文章，从新闻网站爬取后调用各种自动摘要工具生成，共60,000篇。 思路总结 任务一：基础文本分类模型如TextCNN、TextRNN和Fasttext等分别训练，然后模型融合。 任务三：句子相似度计算，然后对召回句子进行优化排序。这里要注意的是，任务三中没有任何的标签，因此是一个无监督的候选句子排序任务。考虑到句子间循环匹配的数量级，我搭建了ElasticSearch全文检索引擎来帮助初选优化，大大降低了检索成本。 模型实现 我在github上的开源代码 比赛心得 任务一： 1.基础模型没能做到极致，仅仅尝试了TextCNN和Fasttext； 2.计算资源要充足，没能把TextRNN做起来的原因有一部分就是实验室的服务器没有GPU…； 3.时间要安排好，工作要分配好，临近毕业实在是太忙了… 任务三： 1.想到用ES来加速查询真的是个非常正确的决定，因为测试集计算量是验证集的200倍; 2.最后实现的还是句子匹配，而非文本理解和溯源。没想到很好的方法。 总的来说，写代码比去年顺手多了，也规范很多。比赛套路也熟悉了很多，从容了一些。但是真的要到进一步提升效果，冲刺排名的时候，就会因为平时积累不够而有心无力。比如说模型融合应该是要基于差异性大的底层模型，这一点我也是在整个比赛结束时才深有体会。再比如Attention和LSTM相关的网络都没能写完、运算完，师哥说的Fasttext能有0.976的结果也没有实现，这些都是因为平时没有去实现过。所以未来还是要好好加油啊！]]></content>
      <tags>
        <tag>Data Mining Contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NLP Internship in Ideepwise Infotech]]></title>
    <url>%2F2018%2F06%2F13%2FNLP-Internship-in-Ideepwise-Infotech%2F</url>
    <content type="text"><![CDATA[2018年3月-2018年6月，我在深思考自然语言处理组担任算法实习工程师 求职面试 是人生中的第二份面试啦，一定程度上算是“老司机”了。 面试分成笔试、上机、技术一面、技术二面、技术三面和HR面。 笔试 有一道概率题，贝叶斯公式带入算一下就可以。 有一道算法题，考的是排序优化，我做出来了，但是方法并不是最好的。 比较奇怪的是，其它几乎都是概念和问答题，机器学习与自然语言处理相关，都不是特别难。 上机 这个算是比较有特色的环节了。 现场要求做一个上机题，关于字符串匹配的，就是要求比较复杂，比如去掉含A的、保留含A但含B的、保留含A但含C且长度小于5的等等，难度不大。不过上机环境是台式机，我不太习惯，还好我习惯去面试带着自己的电脑(首要目的是问到以前工作可以展示代码或界面)。 技术面 一面基本上围绕笔试题，这一次由于有第一次实习的基础，加上我寒假刷了一些leetcode，所以做得还行(其实主要是这次笔试简单了)。 二面主要是白板写算法。印象最深的是问了一个位运算的题：把一个十进制数转换成二进制以后，计算这个二进制数中有多少个1。我用的是最简单的短除法，实现的时候每次减去2的幂就可以了。相比之前的面试，我的进步在于可以白板直接写出来程序了，而缺点还是没有给出最优的方案。算法永无止境，我还需要努力。 三面问了一些实际开发的内容，主要就介绍了SMP CUP 2017(主要是这家公司也参加过这个比赛，虽然不是同一个Track的任务)，以及上一份实习构建问答系统的工作。这里可以插一句，我带电脑真的有用，直接展示了问答系统的前端demo，说服力就很强了(不过很尴尬的是，调用在线搜索后，百度居然直接给了我一个带有色情信息的回答…当时我的脸和面试官一起绿了…还好我机智地说这是即将改进的部分…)。 工作 2018.3：自动问答机器人，主要是套用之前实习开发的系统框架+新公司数据+针对性调整。说实话我觉得这个新公司招我进来重要的原因就是偷学技术…所以在这个过程中我特别注意了数据和参数脱敏的问题，保证保密性(不能违背保密合同)。 2018.4：百度机器阅读理解比赛。尽管我在比赛中实现的实际成果不多，但这份工作经历对我来说比较重要，因为我第一次比较系统地去深入调研和理解了自然语言处理中的某一任务专题，以至于我最终的毕业设计也聚焦在机器阅读理解这项任务上。相关代码和工程还在完善中，之后应该也会开源到我的GitHub上。 2018.5：孪生网络句对相似度计算模型，这份工作来的有点突然，毕竟我本来还是在专心研究机器阅读理解的…目前成果一般，后续可能还会有深入研究，不过它也促进了我对目前自然语言处理领域工作的理解。 感想自然语言处理的核心工作是什么？ 在应用研究层面，应当是文本建模。文本建模意味着什么？意味着通过文本数字化，机器“读懂”了文本。只有理解了文本，机器才能开展文本分类、生成、问答、翻译和阅读理解等工作；只有数字化后的文本能更全面、充分和尽可能少损失地被表示，机器的“智能”才能提升，才更可能拟人。当然，除此以外，能对自然语言处理的研究产生巨大影响的还有文本向量化、模型网络类脑化等工作。只不过它们都不太好上手，文本建模应当是普及最广、被研究最多和进展最快的一类研究。 就我个人观察，文本建模已经从加权tfidf、双向lstm和cnn等方法逐渐往自注意力机制和优化卷积等方法变迁，其中引领潮流的当然是Google著名的《Attention is all your need》一文。在机器翻译和机器阅读理解领域，代表性的新新模型当属Transformer和QANet。 工程和算法的区别？ 在百分点，我更多的是从基础做起，做工程、做产品。五个月里，我锻炼了写代码的能力、熟悉了团队工作环境，知道怎么用wiki、git、filezilla和linux等等一系列东西，可以说是从0到1。 在深思考，我则尝试着去思考自己想做什么，在一定程度突破了代码障碍的基础上，开始学会读论文、追前沿和做模型。算法相比工程最大的区别，就是不必再因为客户的具体需求而去调试参数和设定人工规则，而可以专注于模型本身的设计，去思考学术研究上的优化。我觉得我被这种开创性的研究工作深深吸引着。 换实习要不要“裸辞”？ 原则上不要，因为裸辞会产生空窗期。在空窗期，公司一般不在意我们在学校实验室里做了什么，甚至会认为只是在休息(也就意味着代码实践能力在下滑)。 不足 实习时间太短，没能做更多研究。 公司加班太多(虽然我几乎都没有参与)，我认为被动加班太多只会引起效率下降，劳逸结合、平衡工作和休息才是正道。]]></content>
      <tags>
        <tag>Internship</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Postgraduate Application]]></title>
    <url>%2F2018%2F05%2F31%2FPostgraduate-Application%2F</url>
    <content type="text"><![CDATA[2017年10月-2018年6月，伴随着长达8个月的实习，我度过了漫长而揪心的研究生申请季。我的背景是双非一本信管，GPA90，T101，G160+170+3.5。我申请的方向是CS/DS，最后结果是申11中3，一所平调，一所降调带奖，一所带奖。我是全程自己DIY，没有找中介。 准备学历背景 如果还有的选，一定去一所综合性211/985，尽可能不要去那种“分数并不低于985，所以学校也不差于985”的院校(比如我…)，或者那种“小规模精英办学”的院校(又比如我…)。原因在于：1.外国录取委员会更相信中国政府给出的大学档次排名，而不相信我们自己在文书中对学校品质的努力解释；2.小平台=小资源=小校友圈子=少出国人数=少在录取委员会眼前曝光，同时小资源=少有分量推荐信，小资源=少机会提升自己的软实力。 学历背景是很硬的基础。英国规定的最明确，211/985的同学录取GPA要求比双非一本低5分；美国则是隐性要求，不过这一要求没有那么5分那么多，但3-4分左右是要的。 在这一点，对于我个人，我的办法是去读了北大经双(北京高校同学都可以考)。虽然因为我申请的方向和经济/金融关系很小，帮助不大，但是在我找实习、认识更多学校的优秀同龄人、找推荐信等方面都起过或多或少的作用。 语言考试 语言考试指的是托福、雅思、GRE和GMAT等。我考的是托福和GRE。 托福：我从大二开始断断续续考托福，直到大三暑假才考完，前前后后加起来大半年。因为自己的英语基础确实不好，再加上没有很大块的时间可以专心备考，所以战线只能拉的很长。托福我的总结就是多练，刷阅读刷听力刷口语刷写作。以我的经验，从85到101分大概需要100小时全神贯注的学习(一般来说自习一整天=2小时全神贯注)。 GRE：GRE我确实很占便宜，因为我的强项恰好是阅读。所以尽管GRE我也是断断续续准备，但是因为只需要准备单词部分，就比较轻松。我的GRE是在大三下及八月准备的(中间穿插考了一次托福)，阅读从155进步到160。我对GRE的认识是，这门考试考的是短时间大量练习的消化能力，考前反复背10天单词做50篇阅读和10篇作文，考的时候效果很显著。 GPA 我的GPA其实还不错，虽然用我们学校的绩点计算只有3.65。 网上有很多计算绩点的方法，众说纷纭。其实最好的办法就是直接报百分制GPA，这种制度全世界认可，并且还能用99/98来挽救一下非线性下降的绩点。 还有一种办法是把成绩送去WES认证，这个机构出具的成绩报告是比较有效力的，并且对于中国学生一般会使绩点提高一些。但它认证时间较长且贵(几千RMB)，请自行慎重决定。 推荐信 推荐信不太重要，因为你很难让它很重要。如果能找到蜚声国际的人写推荐信，那么推荐信几乎等于保送。比如我校曾有师哥拿到海牙国际法庭大法官推荐信，直接去了哈佛法学院。 对于一般人来说，推荐信都是学校教授和实习公司领导写。建议学校教授找国际知名度高一些的和对自己非常了解的(上过很多门课的)，实习公司领导则要尽可能去大名气的公司找高级别领导。 中国人的推荐信可以说是国际默认自己写的，这里提示一些推荐信要点：1.扫描一张带有机构title的纸作为pdf文件的背景；2.要一个推荐人的电子签名；3.推荐信不宜过长，要有详有略，末尾写上推荐日期和电子签名；4.和推荐人协商好，把含有所有学校的推荐信提交链接的邮件及时转发给自己；5.提交推荐信的时候可以开VPN来避免ip查重。 这里可以延伸说一下实习，我犯的错误是太忽视公司名气。确实，在公司做了什么项目、学到了什么最重要，但是公司名气同样重要，因为很多录取委员会的人只听说过国际大公司，一个小公司的核心成员的名头很难说服他们。 确定学校及项目 在整个申请中，最重要的是确定学校和想学的项目。 粗选：先确定底线，比如QA排名Top50，然后挨个打开官网搜自己想学方向的关键词(比如传媒=communication、media和advertising等)，把所有搜到的项目页面打开，浏览一遍项目培养目标、课程设置和录取要求。再根据自己的实力(上述四点)，筛选一遍候选项目。 精选：看候选项目的录取细节，要不要准备特殊材料、是不是只给有工作经验的人读，以及学生毕业去向、往年录取比例等等(练T&amp;G阅读终于有了用武之地233)。最终建议锁定大概10-15个项目。 文书 首先根据学校要求，确定有哪些：Personal Statement、Statement of Purpose、Research Proposal、Essay、Essay Video、Resume等等。 根据每个文书下面的具体要求，按学校要求写作(划重点)。这里特别要注意去看项目页面上的FAQs，很多都会有文书材料内必须包含内容的要求，一定要把这些基本要求达到。 文书的写作我建议先按照中文思路，总分总(为啥申请/你的优势123/未来计划)。把每一块儿写清楚了以后，再按照西式思路调整，比如开头用一个引人入胜的小故事、结尾用个自己对这个行业和社会的思考等等，使之文学化、情感化。另外要注意文书重点是体现个人的潜力，不是现有的成就，毕竟录取委员会的人很可能不是特别懂专业上的事。 实在把握不准，可以找文书中介。 网申提前办Visa或Master卡 网申是需要用信用卡的，需要提早办理，以便网申的时候不慌乱。 注意各种deadlines 看项目主页的时候，里面会有申请项目的开放申请和具体截止时间。有的申请是滚动录取的，会明确写上一批二批三批等申请和录取时间点，需要额外注意。其次是要分清国际生和本地生、研究生和博士生的时间界线，一般来说国际生截止日期早于本地生，博士生早于研究生。 准备各种材料 一是明确的邮寄地址、不会失效的电子邮件地址、推荐信作者的联系信息等电子材料。 二是护照扫描件、本科中英文成绩单和在读证明扫描件、获奖证书扫描件、TG成绩单扫描件等实体材料转电子版。 三是在ETS官网购买TG送分服务、WES成绩认证送分服务等电子事务，这些都需要用信用卡支付。 提交及等待 提交完网申以后，注意看看哪些信息还可以继续更新，有的学校还允许继续更新语言成绩(意味着还可以再刷)。 漫长的等待，以及随时注意邮箱(和垃圾邮箱)中学校发来的邮件，看是否有材料需要补充。 如果被调剂了(被该项目拒了，但是推荐了别的项目)，想申请的话就要立刻赶快再填写网申，抢人头。 入学确认Offer(无奖录取=admission，有奖录取=offer，这里用offer统称) 正常的offer发放日期应该是大四寒假及大四下。在比较多家offer后，给最心仪的学校交订金，其它的写信礼貌拒绝。 对确认好的offer尽早开始研究细节，特别重要的是申请I-20表格，这一点对于后面申请签证、体检疫苗和租房等都有影响。一切信息以官网为主，一般会有一个admitted student页面来说明所有事务。 项目细节 很多项目会为被录取者开一个网上研讨会Webinar，来介绍今年项目的各种细节，包括课程设置、教学日历、就业升学、校友资源和学校资源等。这是一个很好的去了解该不该接offer的机会。 签证 务必重视材料的准备！！！ 需要的材料有：1.学校I-20表格；2.个人resume；3.学术型项目需要提供的导师简历；4.DS-160打印页、预约确认单和美签尺寸的照片等使馆要求的必备物品；5.学习计划 面签时要尽早去排队。我是在北京约的7:30到使馆，然而7:10到的时候已经排起了长龙；不过整个流程不算慢，约1小时。 其它细节：1.照片要求比较复杂，深色衬衣和白背景，建议找天真蓝这类机构进行拍摄；2.北京使馆对面是可以存东西的（面签时不能带手机），然而我当时交给街头小贩保管了…损失了100大洋；3.最好找白人男签证官。我分到了全北京拒签率最高的那位亚裔女签证官，然后就GG了…补了很多材料，这几天才通过。 补签：如果被发到221绿表，也不用太紧张，多半是要以邮件形式补充材料。行政审理期大概1周到4周不等，如果当场不留护照的话，最后还得通过中信银行寄送护照回使馆去盖签证（免费寄送）。 体检/疫苗 体检是为了拿到健康证明小红本。疫苗是为了拿到疫苗证明小黄本，同时可能需要完成学校规定的疫苗注射，并请医生填写学校的外文单。 体检/疫苗攻略：https://mp.weixin.qq.com/s/S8FOFCJINn-5v7E-qq1TXg 温馨提示：大城市如北京，一般疫苗种类齐全，但排队人数众多，还需要提前预约；小城市可能疫苗种类不足，需要提取打电话问一下，但是胜在完全没人排队，半小时即可全部搞定。我就是疫苗在北京打，但体检回自家小城市做的。 机票/租房/家具 机票：1.至少提早一个月买，便宜点；2.在第三方平台看好机票后，去该航空的官网买可能会更便宜一点；3.去美国的话飞行时间特别长，建议能买评分高的航空就买高的，舒服一些。比如ANA、卡塔尔航空、南航等等；4.不买直航买转机的话，建议两段旅程都不要飞太久，比如…从香港转就有一段16～17个小时，会累死的= =。 租房：讲道理可以不找中介自己租，但是纽约租房可能是全美最复杂的租房了，所以还是找了在做中介的NYU学长帮忙。有几点tips：1.尽早租房，晚了就没好房源；2.尽早找好合租的人，然后大家按实际使用面积分摊房租，最好在敲定房子前就分配好比例；3.合同签署后48小时内就得付押金等，所以要先准备好一些钱；4.纽约还有一点特殊的就是部分新房需要有当地第三方机构担保，所以还要准备更多的押金… 家具：一般来说新生老生们会拉二手家具交易群，可以随时关注里面的信息。如果不想买二手的，就去亚马逊上买，但是记得地址一定要填到公寓的详细单元号，否则会寄丢(譬如我…)！！！ 感想 最大问题就是学历背景。师哥曾和我说，双非申学校，如果没有比同样申这个学校的985同学各方面都好上一截儿，就别考虑了。现实很残酷，我的申请结果也证明了这一点。 其次问题是太轻视托福。当时老看网上说托福过百即可，所以就没有继续认真刷。但事实上，105+的托福能让一个人从一群100+的申请者中脱颖而出。此外，GRE的重要性远低于托福，G320+T110&gt;&gt;G330+T100。 有好几个项目是我心有不甘的，当时看了地里被录取的人的背景，基本和我一致，唯一区别就是学历和一些软经历。所以说如果当时自己把托福考得更高一点、实习找的名气(比如几乎保送北美top10的msra)再大一些，也许结果就又完全不同了。 第一次有一段很长时间的半夜惊醒去查看邮箱，第一次因为失去信心匆匆忙忙追加保底院校，但也是第一次自己认认真真做完人生的一件大事。不能后悔，不必后悔，也更想感谢一路帮我的朋友们！]]></content>
      <tags>
        <tag>Postgraduate Application</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Siamese-LSTM (孪生网络)]]></title>
    <url>%2F2018%2F05%2F03%2FSiamese-LSTM-%E5%AD%AA%E7%94%9F%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[最近因为公司leader的要求，简单研究了一下孪生网络(Siamese LSTM，一个用来计算句对相似度的模型)。 背景 孪生网络的思想比较简单，是分别利用LSTM对待比较的句对中句子进行建模，然后计算两个隐层向量的曼哈顿距离(Manhattan distance)来评价句子相似度。由于LSTM建模过程一致，因此可以用全部句子训练LSTM的参数，然后参数共享给左右两个LSTM网络。 要点 1.将句子建模网络从LSTM改造为Bi-LSTM+Attention 2.中文训练数据为蚂蚁金服句对数据，约4万组，正负样本比例1:3.6；英文训练数据来自Kaggle上的Quora句对数据，约40万组，比例1:1.7。翻译数据指使用Google Translator将Quora数据翻译成中文(机翻，质量一般)。 资料 参考文献 Siamese Recurrent Architectures for Learning Sentence Similarity How to predict Quora Question Pairs using Siamese Manhattan LSTM 其它数据 英文词向量：GoogleNews-vectors-negative300.bin.gz 英文词向量：GoogleNews-vectors-negative300.bin.gz的百度网盘地址 中文词向量：基于120G中文语料训练的64维、128维词向量 工程参考 likejazz/Siamese-LSTM Original author’s GitHub 做个聊天机器人/智能客服 一些网络设计思路 代码 我的实现 结果123456789$ 根据数据比例来看，中文训练集的基准准确率应为0.783，英文与翻译数据为0.630$ =================================================================================================$ 中文 数据实际训练 5 轮时的效果：使用随机词向量时，训练集十折交叉0.778；使用CN120G词向量时，训练集十折交叉0.789$ 英文 数据实际训练 5 轮时的效果：使用随机词向量时，训练集十折交叉0.774；使用Google词向量时，训练集十折交叉0.771$ 翻译 数据实际训练 5 轮时的效果：使用随机词向量时，训练集十折交叉0.755；使用CN120G词向量时，训练集十折交叉0.756$ =================================================================================================$ 中文 数据实际训练 8 轮时的效果：使用随机词向量时，训练集十折交叉0.777；使用CN120G词向量时，训练集十折交叉0.787$ 英文 数据实际训练 8 轮时的效果：使用随机词向量时，训练集十折交叉0.774；使用Google词向量时，训练集十折交叉0.778$ 翻译 数据实际训练 8 轮时的效果：使用随机词向量时，训练集十折交叉0.786；使用CN120G词向量时，训练集十折交叉0.786 总结 1.有无预训练词向量几乎不影响结果。 2.中文数据上训练几乎没有效果，和英文形成鲜明对比–这是因为蚂蚁金服数据间太相似了或者数据量太小，翻译数据集上的实验证明了这一点。 3.孪生网络的效果没有想象中的那么好，后续还会继续从调参、加停用词等角度进行研究。此外，之前在QA机器人中用CNN来做句子语义匹配时缺少数据，现在这里的数据可以用了！233]]></content>
      <tags>
        <tag>SentenceMatching</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My QA Robot]]></title>
    <url>%2F2018%2F04%2F01%2FMy-QA-Robot%2F</url>
    <content type="text"><![CDATA[从2017年10月-2018年3月，出于实习公司的要求，我尝试搭建了一个简单的单轮检索式问答系统。 背景 目前，自动问答技术的实现主要有阅读式、检索式和生成式三大类。 阅读式：指机器阅读理解，通过给定文章和针对文章提出的具体问答对训练机器的阅读理解能力，并对针对文章的新问题作出回答。机器阅读理解包括passage-based、assertion-based、sentence-based和answer-span-based等不同粒度。阅读式的问题是知识边界狭窄，训练语料构筑困难，较适合于专业领域的机器人。 生成式：指使用Seq2Seq搭配海量语料训练具有自主对话能力的系统。生成式理论上可实现不受知识局限的通用机器人，但目前生成式最大的问题是答非所问、胡言乱语，无法表现出人类在解决问题时的逻辑自洽、思维发散和自然表达等能力。这个实现技术比较多用在闲聊机器人方面。 检索式：检索式是一种取长补短的中间无监督技术。检索式要求搜集众多在线问答网站海量的历史问答对语料作为知识库，通过检索与新问题最接近的历史相似问题和最匹配这一新问题的历史最佳问答，变相完成自动问答任务。检索技术既避免了知识的局限，又利用了人类的先验经验积累，是当前处理通用问答任务较合适的方法之一。 思路 结合实际，我的设计为：1.通过爬虫和用户历史数据建立QA式本地知识库；2.当给定用户新问题时，系统先通过ES（ElasticSearch，ES原理）进行词义级的本地检索得到参考问答初选集；3.使用语义深度匹配和问答质量评估从初选集中精选出参考问答精选集，按得分降序返回最终参考问答；4.若没有任何问答通过精选，则启动在线搜索获取标识有“最佳问答”的参考问答返回给用户，并将其中的优质问答缓存到本地ES索引中。 变量或参数名 说明 StopWords 停用词表 KeyWords 核心主题词表 Text_Main_Content(TMC) 用户新问题经分词、去除停用词后的分词结果 Keywords_in_Content(KIC) 用户新问题命中的核心主题词 Text_NER_List(TNL) 用户新问题中的分词后的NER Question_Main_Content(QMC) ES本地检索返回的候选问题经分词、去除停用词后的分词结果 QuestionScore(QS) 语义匹配模块返回的候选问题与新问题的相似度得分 AnswerScore(AS) 通过答案排序模块计算出的，候选问题对应的候选答案与用户新问题组成“好问答对”的概率得分 FinalScore(FS) 候选问答在精选规则下的最终得分 THRESHOLD 控制在精选集中记录ES初选结果的阈值。 ZHIDAOMAX 控制在线搜索时从百度知道返回的问答数量。 SAVESCORE 控制增量存储模块中的百度知道问答对的阈值 ESMAX 控制精选集中的精选问答数量 子模块 根据上文项目思路的介绍，除主函数外，共调用了语义深度匹配、问答质量评估和在线搜索缓存三大子模块 语义深度匹配子模块：参考项目 句对预处理及建模: 将输入的句子1与句子2进行分词，然后将两组切分后的结果两两计算基于Word Embedding的余弦相似度，并填充成上图所示的2D Feature Map形式。当句对的分词list长度不同时，使用0填充缺失值。 模型训练与调用：训练时，将训练集句对的Feature Map输入到CNN模型中，获取语义匹配模型并保存；预测时，调用预训练好的语义匹配模型，输入新句对的Feature Map，将返回这组句对的相似概率得分。 问答质量评估子模块：使用若干文本和非文本特征训练二分类器，参考论文 在线搜索缓存子模块： 百度主页搜索: 向百度主页请求输入用户新问题后的检索结果，若检索结果的第一条中包含预设结果链接，则获取内容并向用户返回。 百度知道搜索：当百度主页搜索没有结果时，在百度知道页面请求输入用户新问题后的检索结果，若Top K条结果中包含带有“最佳回答”标识的回答，则获取对应问答内容并返回。 本地缓存优质问答：当百度知道搜索有结果返回时，调用问答质量评价子模块对该问答对进行质量判断，将高于设定阈值(SAVESCORE)的问答对缓存到本地知识库。缓存机制有助于后续提升系统整体的响应速度及性能。 代码 My QA Robot 总结 项目内：1.项目执行时，语义深度匹配子模块缺少合适的负样本(词义上相似但语义不相似的句对)；2.各种参数阈值很难调试。 项目外：工程性太重，并且以检索为主，在语义理解、匹配和推理方面展开太少。]]></content>
      <tags>
        <tag>QuestionAnswering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Assertion-based QA with Question-Aware Open Information Extraction]]></title>
    <url>%2F2018%2F03%2F26%2FAssertion-based-QA-with-Question-Aware-Open-Information-Extraction%2F</url>
    <content type="text"><![CDATA[实验室组会分到一篇断言式QA的论文，阅读后总结如下 背景AAAI 2018 要点 1.定义了基于断言的QA任务(Assertion-based QA) 2.标注了一个Assertion-based QA数据集 3.提出了能够完成Assertion-based QA的两个算法，抽取法和生成法 4.设计了一些实验证明以上方法的效力 内容定义 文章首先介绍了从document_based QA和Assertion_based QA的区别与联系。 文章中的断言指的是具有主谓宾、主谓宾补等结构的句子，该句子可能是给定材料的一部分，也可能是新生成的。 数据集 由于Assertion-based QA是第一次被提出，所以作者团队标注了一个数据集来做具体的研究(666)。 标注方法是先用OIE工具+is-a规则从背景材料中抽取候选断言，然后人工标注断言是否可以作为答案。 算法 第一种算法是生成法。首先用bi-lstm分别对问题和材料编码，拼接尾部隐状态作为特征表示。其次先用一个元组级解码器(Tuple-level decoder)生成结构，然后再用词级别解码器(Word-level Decoder)在结构中逐个生成需要填充的词。下图来自PPT，但是缺了不少信息，我做了批注。 第二种算法是抽取法。抽取法的本质就是对所有候选断言进行机器排序，过程和人工标注很相似。这里的机器排序算法是开源的LambdaMART算法。需要指出的是，这个方法思路很简单，但是做的比较精致的是特征工程，分别从word、phrase和sentence level抽取了特征进行组合。前两类特征比较简单，sentence level使用了CNN和GRU组合来抽取隐藏层的语义交互特征。下图同样来自PPT，其中包含一些和论文对不上的内容，最后是通过邮件和作者沟通后补充了部分，详情见批注。 实验 实验部分文章主要做了4个实验：分别测试生成法和抽取法的效果，以及很创新地分别把生成与抽取的结果再编码成特征放到Passage_based QA中去。后面两个实验是为了证明Assertion_based QA具有更多研究价值，可以辅助别的QA任务。 不过我感觉PPT有点“王婆卖瓜，自卖自夸”。我从文章中摘了一张针对后两个实验和其它算法一起比较效果的图放在下面，数据显示：1.工程性更重的抽取法效果好于生成法；2.CNN等方法得到的特征效果好于抽取法。 资料 译文和PPT 总结 总的来说，这篇论文确实做了非常多且较完整的开创性工作，特别是Assertion-based QA的定义和数据集，为QA领域开辟了一些新的思路。尽管提出的算法效果比较一般，但是也可以视作该领域的baseline之一，以鼓励更多更优秀的算法和模型出现。]]></content>
      <tags>
        <tag>QuestionAnswering</tag>
        <tag>Paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Mining & NLP Internship in BaiFenDian Infotech]]></title>
    <url>%2F2018%2F03%2F20%2FData-Mining-NLP-Internship-in-BaiFenDian-Infotech%2F</url>
    <content type="text"><![CDATA[2017年10月-2018年3月，我在百分点自然语言处理组担任数据挖掘实习工程师 求职面试 其实面试真的很糟糕… 因为是第一份实习，而且当时真的是很弱的小白一只(现在也是= =)，所以面试几乎都没有答上来。 面试分成笔试、技术一面、技术二面和HR面。 笔试印象最深的是第一题，问有一个信号发射器，每次以不均等的概率发射0或1信号，如何组合出一个以均等概率发射0或1的信号发射器？如何组合出一个以均等概率发射0…N的信号发射器？然后…我很想当然地以为是像N次独立二项试验一样组合概率就可以，其实是要模拟二进制数。后面记不太清楚了，基本都是NLP编程题，读取文本之类的。还记得有一个算法题是要优化排序，然而我直接写用list.sort()不就好了…然后技术面就被问了list.sort()内部用的什么排序算法= =…最后就是一些机器学习的概念题，KNN和Kmeans概念之类的，比较简单。 技术面 一面基本上围绕笔试题，被疯狂吐槽了一番各种错误，基本上每道题都有错…后来坚定了我刷leetcode的决心… 二面问了一些实际开发的内容，先是介绍自己做过的SMP CUP 2017，再是问了诸如神经网络怎么防止过拟合等问题。说实话，这种沟通型面试我还是挺擅长的…各种嘴炮护体。 工作 工程方面：论坛帖子分类、检索式社区问答系统搭建 算法方面：利用N-gram和CNN实现相似句对判断、问答对质量评估，都是在问答系统搭建里面做的子模块 客户方面：一个远程电话支持，一个客户现场技术支持(我一个小小的实习生，怎么就跟着去做了售前呢…可能是我的嘴炮能力被发现了= =) 感想这个行业挣钱多不多？多。2017年可以说是中国的人工智能和机器学习元年。我们每天的数据中有80%是文本数据，所以以NLP为基础的数据处理业务增长迅速。大量的公司在分蛋糕，并且分得很轻松，俗称“降维打击”：大量的公司只是觉得人工智能高大上，实际上弱AI和机器学习很简单，各种工程用的都是github上的开源代码… 工作具体干什么？两类工作：业务线与产品线。业务指的是接销售、产品给的项目，然后做定制化开发；当然有的时候也包括售前支持，比如说去客户现场做技术支援。产品线指的是开发通用产品，比如说我一直负责开发的自动问答系统，甚至还包含了一点点算法研究的意味在里面。 能力要求怎么样？三个能力最重要：自己网上找资料的能力，熟练的代码能力和持续加班的身体能力。 要怎么培养能力？“偷看”公司以前的积累(来自前辈的教导~)多和同事聊天，勤问勤练；好记性不如烂笔头，把每天的事情都总结下来，调研+开发等多写代码，养成优秀的代码习惯：加注释+readme！！！想清楚自己的未来发展方向：工作？升学？但不管哪种，建议多读书..很多时候有啥不理解的，一看相关论文就有了思路。所以说我感觉这个领域读深一点真的没坏处，需要知识积累。 不足百分点以前一直是一个大数据工程公司，现在开始转型AI。正因如此，并且由于企业需要生存，它很多时候经营思路还是做工程，很少有沉下心来做算法研究的机会。我认为自己在工程上已经学到一点皮毛了，尽管很轻浮，但我还是希望能去一个研究型的AI公司感受一下算法研究工程师的工作∠( ᐛ 」∠)＿～]]></content>
      <tags>
        <tag>Internship</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SMP CUP 2017]]></title>
    <url>%2F2017%2F08%2F31%2FSMP-CUP-2017%2F</url>
    <content type="text"><![CDATA[SMP CUP 2017是我参加的第一个数据挖掘类比赛。 比赛简介给定CSDN用户的博客和行为数据（浏览、评论、收藏、转发、点赞/踩、关注、私信），进行用户画像生成。赛事官网地址：https://biendata.com/competition/smpcup2017/画像生成总共分为三项任务： 从给定博文中抽取3个关键词标签 从给定标签空间中选出3个来给给定用户打标签，依据是用户发表的博文以及一系列行为数据 通过给定用户过去一段时间的行为数据，预测其在未来一段时间内的成长值。用户成长值是根据用户的综合表现打分所得，但不知道具体打分准则。成长值将会归一化到[0, 1]区间，其中值为0表示用户流失。 数据样例 项目 内容 用户ID U00296783 博文ID D00034623 博文内容 Title:[转]使用TextRank算法为文本生成关键字和摘要; Content: TextRank算法基于PageRank… 博文标签 Keyword1: TextRank; Keyword2: PageRank; Keyword3: 摘要 用户标签 Tag1: 大数据; Tag2: 数据挖掘; Tag3: 机器学习 发布记录 U00296783／D00034623／20160408 12:35:49 浏览记录 D09983742／20160410 08:30:40 评论记录 D09983742／20160410 08:49:02 点赞记录 D00234899／20160410 09:40:24 点踩记录 D00098183／20160501 15:11:00 私信记录 U00296783／U02748273／20160501 15:30:36 收藏记录 D00234899／20160410 09:40:44 关注记录 U00296783／U02666623／20161119 10:30:44 成长打分 0.0367 (注：浏览、评论、点赞、点踩和收藏指的是该用户对其它博文的行为) 思路总结 抽取关键词其实方法也不太多，一开始想到的办法就是利用tfidf和textrank。后来查阅到了一些2016年搜狗CCF比赛的资料，就尝试把LDA抽取出来的主题关键词作为规则融合进来。简而言之，就是不断调整tfidf和textrank赋予给每个词的权重，尽可能地去提升比赛评分标准下的得分。 任务二大概的做法是先把用户行为分类转化成对应的文章，发表行为下的文章是一类，浏览的、评论的、点赞点踩的、收藏的文章是一类，私信和关注的用户所写的文章是一类。这个假设非常的主观，我们当时的依据就是用户做这些行为的成本不一样，比如说发表文章比较累…所以这些文章可以被分成3类，刚好对应3个标签(其实简单对训练集做了统计发现这个规律也确实还有一点点道理)。之后就是让每一类文章投票选出一个最可能的标签，分类方法是tfidf加权生成句向量+SVC。 成长值这个任务其实一看就是和时间序列有关的，但是局限于代码水平…当时就直接当作一个简单的回归问题来处理。先手动抽取了一些特征，比如每个用户过去每个月的评论数及增长率等，然后直接丢到PassiveAggressive和GrandientBoosting分类器里面，加一个Stacking做了融合预测。 模型实现 我在github上的开源代码 论文链接 比赛心得 任务1：现在回过头来看这个方法真的非常稚嫩，但是倒也相当符合“规则派”的做法，毕竟我后来的实习工作中也证明了规则的有效性。不过第一名中科院团队的做法是纯正的神经网络，用来多个Softmax来投票，效果比第二名好了一大截，我怀疑除了他们大家都是tfidf+规则… 任务2：最开始采用了TextCNN的方法，但是效果比较一般，主要是不知道怎么把单标签分类的模型改成多标签…现在想想其实就是一个SoftMax…任务2我们的效果是最差的，我猜测就是因为主观假设太强了。 任务3：说实话这个模型的效果竟然意外的好，我觉得应该是因为纯数字数据的原因，毕竟对于数字，机器还是很容易去“拟合”一个模型出来的。 不过总的来说，当时真的是年轻头铁硬扛…开始比赛前，我连sklearn和numpy这些必备的包都不会用，更别说tensorflow和keras了。当时也是运气好，比赛因故延期了很长时间，我在比赛中期发现了kaggle和泰坦尼克数据集，并且由此自学了一堆机器学习的东西，才最后踉踉跄跄搞出了任务3的模型。像时间序列预测等等都没法做出来，很重要的原因是花了很长时间自学这些底层的东西，虽然按理来说应该在赛前就先打好基础的。不过回头看，此前整个实验组都没有经验，因为我们的辛苦帮老师和实验组做了一些开拓性的事情，还是非常让人喜悦的。]]></content>
      <tags>
        <tag>Data Mining Contest</tag>
      </tags>
  </entry>
</search>
